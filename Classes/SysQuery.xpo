Exportfile for AOT version 1.0 or later
Formatversion: 1

***Element: CLS

; 
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #SysQuery
    PROPERTIES
      Name                #SysQuery
      Extends             #Query
      Origin              #{2D080B41-0000-1000-5379-735175657279}
      LegacyId            #2881
    ENDPROPERTIES
    
    METHODS
      SOURCE #classDeclaration
        #/// <summary>
        #/// The <c>SysQuery</c> class enables you to create, read, update, and delete X++ code and metadata.
        #/// Make sure that the user has access to the <c>SysDevelopment</c> security key before they call this
        #/// API.
        #/// </summary>
        #/// <remarks>
        #/// Makes sure that the user has access to the development security key, a <c>SysDevelopment</c> value,
        #/// before they call this API.
        #/// </remarks>
        #// This is a framework class. Customizing this class may cause problems with future upgrades to the software.
        #class SysQuery extends Query
        #{
        #    #Query
        #
        #    #define.companyId(1)
        #    #define.isSelected(2)
        #
        #    #define.validTimeStateQueryType(1)
        #    #define.validTimeIsDatetime(2)
        #    #define.validTimeRanges(3)
        #
        #    #localmacro.dimensionDataSourceRangeCurrentList
        #        dataSourceName,
        #        dimensionFieldName,
        #        dimensionAttributeName,
        #        rangeEnabled,
        #        rangeStatus,
        #        rangeValue,
        #        dimensionComponent,
        #        isDefaultRange
        #    #endmacro
        #
        #    #localmacro.dimensionDataSourceOrderByCurrentList
        #        dimensionDataSourceName,
        #        dataSourceName,
        #        dimensionFieldName,
        #        dimensionAttributeName,
        #        direction,
        #        dimensionComponent
        #    #endmacro
        #}
      ENDSOURCE
      SOURCE #addCollectedSelectionFields
        #/// <summary>
        #/// This method adds collected selection fields to the
        #/// query data sources' field selection list.
        #/// </summary>
        #/// <param name="_query">
        #/// A query with aggregate fields.
        #/// </param>
        #/// <param name="_collectedSelectionFields">
        #/// A map of collected selection fields
        #/// </param>
        #private static void addCollectedSelectionFields(Query _query, Map _collectedSelectionFields)
        #{
        #    MapEnumerator me;
        #
        #    int dataSourceUniqueId;
        #    List collectedfieldsList;
        #    ListEnumerator fieldEnum;
        #
        #    QueryBuildFieldList qbfl;
        #    FieldId selField;
        #    SelectionField selType;
        #
        #    if (_collectedSelectionFields!=null)
        #    {
        #        me = _collectedSelectionFields.getEnumerator();
        #        while(me.moveNext())
        #        {
        #            dataSourceUniqueId = me.currentKey();
        #            qbfl = _query.dataSourceUniqueId(dataSourceUniqueId).fields();
        #
        #            collectedfieldsList = me.currentValue();
        #            fieldEnum = collectedfieldsList.getEnumerator();
        #            while(fieldEnum.moveNext())
        #            {
        #                [selField,selType] = fieldEnum.current();
        #                qbfl.addField(selField,selType);
        #            }
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #addDimensionAttributeFilter
        #/// <summary>
        #/// Adds the appropriate joins and filters to the query to filter results by
        #/// a specific dimension attribute and value.
        #/// </summary>
        #/// <param name="_query">
        #/// The query to update.
        #/// </param>
        #/// <param name="_dataSourceName">
        #/// The name of the datasource containing the dimension information.
        #/// </param>
        #/// <param name="_dimensionFieldName">
        #/// The name of the field on the datasource containing the dimension information.
        #/// </param>
        #/// <param name="_dimensionComponent">
        #/// The dimension component within the dimension information to pivot.
        #/// </param>
        #/// <param name="_value">
        #/// The value to which results should be restricted.
        #/// </param>
        #/// <param name="_dimensionAttributeName">
        #/// The name of the dimension attribute for which the value should be applied.
        #/// </param>
        #/// <returns>
        #/// The QueryBuildRange used to restrict the query.
        #/// </returns>
        #/// <remarks>
        #/// If no dimension attribute name is specified and the field is a ledger dimension,
        #/// then the query will restrict based upon the denormalized combination string.
        #///
        #/// If a value is not specified and the field is not an enumeration dimension, then
        #/// the query will restrict to only records containing no value for the specified
        #/// dimension.
        #/// </remarks>
        #public static QueryFilter addDimensionAttributeFilter(Query _query, str _dataSourceName, str _dimensionFieldName, DimensionComponent _dimensionComponent, anytype _value, str _dimensionAttributeName='')
        #{
        #    DimensionProviderBase provider;
        #    QueryFilter ret;
        #
        #    provider = SysQuery::getDimensionProviderFromFieldInQuery(_query,_dataSourceName,_dimensionFieldName);
        #    if (provider)
        #    {
        #        ret = provider.addAttributeFilterToQuery(_query,_dataSourceName, _dimensionFieldName, _dimensionComponent, _value, _dimensionAttributeName);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addDimensionAttributeRange
        #/// <summary>
        #///    Adds the appropriate joins and ranges to the query to filter the results by a specific dimension
        #///    attribute and value.
        #/// </summary>
        #/// <param name="_query">
        #///    The query to update.
        #/// </param>
        #/// <param name="_dataSourceName">
        #///    The name of the data source that contains the dimension information.
        #/// </param>
        #/// <param name="_dimensionFieldName">
        #///    The name of the field on the data source that contains the dimension information.
        #/// </param>
        #/// <param name="_dimensionComponent">
        #///    The dimension component within the dimension information to pivot.
        #/// </param>
        #/// <param name="_value">
        #///    The value to which results should be restricted.
        #/// </param>
        #/// <param name="_dimensionAttributeName">
        #///    The name of the dimension attribute for which the value should be applied.
        #/// </param>
        #/// <param name="_isDefaultRange">
        #///    true if the range is being added only as a default; otherwise false.
        #/// </param>
        #/// <returns>
        #///    The query build range that is used to restrict the query.
        #/// </returns>
        #/// <remarks>
        #///    If no dimension attribute name is specified and the field is a ledger dimension, the query will
        #///    restrict based on the denormalized combination string.If a value is not specified and the field is
        #///    not an enumeration dimension, the query will restrict to only records that contain no value for the
        #///    specified dimension.
        #///
        #///    A default range with an empty value will not cause a notexists query to be generated as would normally
        #///    happen with an explicit empty string value.
        #/// </remarks>
        #public static QueryBuildRange addDimensionAttributeRange(Query _query, str _dataSourceName, str _dimensionFieldName, DimensionComponent _dimensionComponent, anytype _value, str _dimensionAttributeName='', boolean _isDefaultRange = false)
        #{
        #    DimensionProviderBase provider;
        #    QueryBuildRange ret;
        #
        #    provider = SysQuery::getDimensionProviderFromFieldInQuery(_query,_dataSourceName,_dimensionFieldName);
        #    if (provider)
        #        ret = provider.addAttributeRangeToQuery(_query,_dataSourceName, _dimensionFieldName, _dimensionComponent, _value, _dimensionAttributeName, _isDefaultRange);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addDimensionDataSource
        #/// <summary>
        #///    Adds the appropriate joins to the query to pivot the specified dimension information as a column on
        #///    the query.
        #/// </summary>
        #/// <param name="_query">
        #///    The query to update.
        #/// </param>
        #/// <param name="_dataSourceName">
        #///    The name of the data source that contains the dimension information.
        #/// </param>
        #/// <param name="_dimensionFieldName">
        #///    The name of the field on the data source that contains the dimension information.
        #/// </param>
        #/// <param name="_dimensionComponent">
        #///    The dimension component within the dimension information to pivot.
        #/// </param>
        #/// <param name="_dimensionAttributeName">
        #///    The name of the dimension attribute to pivot.
        #/// </param>
        #/// <returns>
        #///    The <c>QueryBuildDataSource</c> data source that contains the pivoted column.
        #/// </returns>
        #/// <remarks>
        #///    If no dimension attribute is specified and the dimension information is a ledger dimension, the
        #///    denormalized combination string will be pivoted instead of individual dimension values.
        #/// </remarks>
        #public static QueryBuildDataSource addDimensionDataSource(Query _query, str _dataSourceName, str _dimensionFieldName, DimensionComponent _dimensionComponent, str _dimensionAttributeName = '')
        #{
        #    DimensionProviderBase provider;
        #    QueryBuildDataSource ret;
        #
        #    provider = SysQuery::getDimensionProviderFromFieldInQuery(_query, _dataSourceName,_dimensionFieldName);
        #
        #    if (provider)
        #    {
        #        ret = provider.addDataSourceToQuery(_query, _dataSourceName, _dimensionFieldName, _dimensionComponent, _dimensionAttributeName);
        #    }
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #addFilterFromKeyData
        #/// <summary>
        #/// Adds key data as filters to the query
        #/// </summary>
        #/// <param name="query">
        #/// The query over which the filters need to be added
        #/// </param>
        #/// <param name="qbds">
        #/// The query build datasource
        #/// </param>
        #/// <param name="keyData">
        #/// A container that typically has information that includes version, data type, range type and size
        #/// </param>
        #/// <remarks>
        #/// Filters will be added only if the container size is at least 4
        #/// Can't be an instance method because new queryRun() until takes a query!
        #/// </remarks>
        #static void addFilterFromKeyData(Query query,
        #    QueryBuildDataSource    qbds,
        #    KeyData                 keyData     // Must be a unique list of values!
        #    )
        #{
        #    Map                     keyDataMap;
        #    MapEnumerator           me;
        #    QueryFilter             queryFilter;
        #
        #    // A local a method is used because the a variable can change type for each while loop
        #    anytype a()
        #    {
        #        anytype a;
        #        [a] = me.currentValue();
        #        return a;
        #    }
        #    //Only do Map::create() when container has at least 4 parameters. version,domain type,
        #    //range type and size
        #    if (conLen(keyData) >= 4)
        #    {
        #        keyDataMap = Map::create(keyData);
        #
        #        me = keyDataMap.getEnumerator();
        #        while (me.moveNext())
        #        {
        #            queryFilter = SysQuery::findOrCreateQueryFilter(query,qbds,fieldId2name(qbds.table(),me.currentKey()));
        #            queryFilter.value(queryValue(a()));
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #addIndexToOrderBy
        #/// <summary>
        #///    Adds the fields of an index to the order by list of a <see cref="T:QueryBuildDataSource" /> object.
        #/// </summary>
        #/// <param name="indexName">
        #///    The index name.
        #/// </param>
        #/// <param name="qbds">
        #///    The <c>QueryBuildDataSource</c> object.
        #/// </param>
        #public static void addIndexToOrderBy(str indexName, QueryBuildDataSource qbds)
        #{
        #    DictIndex dictIdx;
        #    int idxID;
        #    TableId tableId;
        #    int pos, fldCount;
        #    ;
        #
        #    if (qbds)
        #    {
        #        tableId = qbds.table();
        #        idxID = indexName2id(tableId, indexName);
        #
        #        dictIdx = new DictIndex(tableId, idxID);
        #        if (dictIdx)
        #        {
        #            fldCount = dictIdx.numberOfFields();
        #            for (pos = 1; pos <= fldCount; pos++)
        #            {
        #                qbds.addOrderByField(dictIdx.field(pos));
        #            }
        #        }
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #addLockRange_RU
        #static QueryBuildRange addLockRange_RU(QueryBuildDataSource _queryBuildDataSource,
        #                                       FieldId              _fieldId,
        #                                       str                  _value,
        #                                       boolean              _clear = false)
        #{
        #    QueryBuildRange queryBuildRange;
        #
        #    if (_queryBuildDataSource && _fieldId)
        #    {
        #        if (_clear && _queryBuildDataSource.findRange(_fieldId))
        #        {
        #            _queryBuildDataSource.clearRange(_fieldId);
        #        }
        #
        #        queryBuildRange = _queryBuildDataSource.addRange(_fieldId);
        #        queryBuildRange.value(_value);
        #        queryBuildRange.status(RangeStatus::Locked);
        #    }
        #
        #    return queryBuildRange;
        #}
      ENDSOURCE
      SOURCE #addOrderByDimensionAttribute
        #/// <summary>
        #///    Sorts the query by the specified dimension information.
        #/// </summary>
        #/// <param name="_query">
        #///    The query to update.
        #/// </param>
        #/// <param name="_dataSourceName">
        #///    The name of the data source that contains the dimension information.
        #/// </param>
        #/// <param name="_dimensionFieldName">
        #///    The name of the field on the data source that contains the dimension information.
        #/// </param>
        #/// <param name="_dimensionComponent">
        #///    The dimension component within the dimension information to pivot.
        #/// </param>
        #/// <param name="_sortOrder">
        #///    The order in which the results should be sorted.
        #/// </param>
        #/// <param name="_dimensionAttributeName">
        #///    The name of the dimension attribute for which the sorting should be applied.
        #/// </param>
        #/// <remarks>
        #///    If no dimension attribute name is specified and the field is a ledger dimension, the query will
        #///    sort based on the denormalized combination string.
        #/// </remarks>
        #public static void addOrderByDimensionAttribute(Query _query, str _dataSourceName, str _dimensionFieldName, DimensionComponent _dimensionComponent, SortOrder _sortOrder = SortOrder::Ascending, str _dimensionAttributeName='')
        #{
        #    DimensionProviderBase provider;
        #
        #    provider = SysQuery::getDimensionProviderFromFieldInQuery(_query, _dataSourceName,_dimensionFieldName);
        #    if (provider)
        #    {
        #        provider.addOrderByAttribute(_query,_dataSourceName, _dimensionFieldName, _dimensionComponent, _sortOrder, _dimensionAttributeName);
        #    }
        #}
      ENDSOURCE
      SOURCE #addRangesFromKeyData
        #// Can't be an instance method because new queryRun() until takes a query!
        #static void addRangesFromKeyData(
        #    QueryBuildDataSource    qbds,
        #    KeyData                 keyData     // Must be a unique list of values!
        #    )
        #{
        #    Map                     keyDataMap;
        #    MapEnumerator           me;
        #
        #    // A local a method is used because the a variable can change type for each while loop
        #    anytype a()
        #    {
        #        anytype a;
        #        [a] = me.currentValue();
        #        return a;
        #    }
        #    //Only do Map::create() when container has at least 4 parameters. version,domain type,
        #    //range type and size
        #    if (conLen(keyData) >= 4)
        #    {
        #        keyDataMap = Map::create(keyData);
        #
        #        me = keyDataMap.getEnumerator();
        #        while (me.moveNext())
        #        {
        #            qbds.addRange(me.currentKey()).value(queryValue(a()));
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #addTableRelation
        #public static Query addTableRelation(Query query, TableId tableId)
        #{
        #    Query                   retQuery = new Query(query.pack());
        #    QueryBuildDataSource    qbds1;
        #    QueryBuildDataSource    qbds2;
        #
        #    qbds1 = retQuery.dataSourceNo(1);
        #    qbds2 = qbds1.addDataSource(tableId);
        #
        #    qbds2.relations(true);
        #
        #    return retQuery;
        #}
      ENDSOURCE
      SOURCE #clearAndCollectSelectionFields
        #/// <summary>
        #/// Clears fields from a query that are not of type database or computed column
        #/// </summary>
        #/// <param name="_query">
        #/// Query that selection fields should be removed from.
        #/// </param>
        #/// <returns>
        #/// Map of selection fields to be collected
        #/// </returns>
        #/// <remarks>
        #/// field list will only be cleared if it contains aggregates
        #/// </remarks>
        #private static Map clearAndCollectSelectionFields(Query _query)
        #{
        #    Map selectionFields;
        #
        #    int dataSourceNo, dataSourceCount, fieldNo, fieldCount;
        #    List fieldList;
        #    ListEnumerator fieldEnum;
        #    QueryBuildDataSource qbds;
        #    QueryBuildFieldList qbfl;
        #    SelectionField selectionType;
        #    FieldId selField;
        #    SelectionField selType;
        #
        #    boolean shouldClearAndCollect = false;
        #
        #    //Clear the selection fields for all datasources
        #    dataSourceCount = _query.dataSourceCount();
        #    for (dataSourceNo=1; dataSourceNo<=dataSourceCount; dataSourceNo++)
        #    {
        #        fieldList = new List(Types::Container);
        #        qbds = _query.dataSourceNo(dataSourceNo);
        #
        #        //Set the selection found flag back to false for each datasource
        #        shouldClearAndCollect = false;
        #
        #        //Save the list of database fields
        #        qbfl = qbds.fields();
        #        fieldCount = qbfl.fieldCount();
        #
        #        for (fieldNo = 1; fieldNo <= fieldCount; fieldNo++)
        #        {
        #            selectionType = qbfl.fieldKind(fieldNo);
        #            if (selectionType == SelectionField::Database || selectionType == SelectionField::ComputedColumn)
        #            {
        #                fieldList.addEnd([qbfl.field(fieldNo), selectionType]);
        #            }
        #            else
        #            {
        #                shouldClearAndCollect = true;
        #            }
        #        }
        #
        #        //Only need to remove and re-add non-selection fields if selection fields were found
        #        if (shouldClearAndCollect == true)
        #        {
        #            //Remove all the selection fields
        #            qbfl.clearFieldList();
        #
        #            if ( fieldList.elements() > 0 )
        #            {
        #                if ( _query.queryType() == QueryType::Union )
        #                {
        #                    //AX#190443
        #                    //For union queries, we collect the non-aggregate fields so that
        #                    //they can be appended to the field selection list after
        #                    //aggregates have been added.
        #                    if ( selectionFields == null )
        #                    {
        #                        selectionFields = new Map(Types::Integer,Types::Class);
        #                    }
        #                    selectionFields.insert(qbds.uniqueId(),fieldList);
        #                }
        #                else
        #                {
        #                    //For non-union queries, we'll just add the non-aggregate fields
        #                    //and append aggregates later.
        #                    fieldEnum = fieldList.getEnumerator();
        #                    while(fieldEnum.moveNext())
        #                    {
        #                        [selField,selType] = fieldEnum.current();
        #                        qbfl.addField(selField,selType);
        #                    }
        #                }
        #            }
        #        }
        #    }
        #
        #    return selectionFields;
        #}
      ENDSOURCE
      SOURCE #clearDimensionRangesFromQuery
        #/// <summary>
        #///    Clears all ranges related to the dimension field in the input query.
        #/// </summary>
        #/// <param name="_query">
        #///    The input query.
        #/// </param>
        #public static void clearDimensionRangesFromQuery(Query _query)
        #{
        #    List                    list;
        #    ListEnumerator          listEnum;
        #    DimensionProviderBase   providerClass;
        #
        #    list = SysDictType::getAllDimensionProviders();
        #    listEnum = list.getEnumerator();
        #    while (listEnum.moveNext())
        #    {
        #        providerClass = listEnum.current();
        #        providerClass.clearDimensionRangesFromQuery(_query);
        #    }
        #}
      ENDSOURCE
      SOURCE #copyDynalinks
        #// AOSRunMode::called
        #public client server static Query copyDynalinks(Query _newQuery, Query _originalQuery)
        #{
        #    QueryBuildDynalink      dynaLink;
        #    QueryBuildDataSource    newDataSource;
        #    QueryBuildDataSource    originalDataSource;
        #    int                     dataSourceCnt;
        #    int                     dynalinkCnt;
        #    int                     i, j;
        #
        #    if (_originalQuery &&
        #        _newQuery)
        #    {
        #        dataSourceCnt = _originalQuery.dataSourceCount();
        #
        #        for (i=1; i <= dataSourceCnt; i++)
        #        {
        #            originalDataSource  = _originalQuery.dataSourceNo(i);
        #            if (originalDataSource.enabled())
        #            {
        #                newDataSource       = _newQuery.dataSourceNo(i);
        #                dynalinkCnt         = originalDataSource.dynalinkCount();
        #
        #                for ( j=1; j <= dynalinkCnt; j++)
        #                {
        #                    dynaLink = originalDataSource.dynalink(j);
        #                    newDataSource.addDynalink(dynaLink.field(), dynaLink.cursor(), dynaLink.dynamicField());
        #                }
        #            }
        #        }
        #    }
        #    return _newQuery;
        #}
      ENDSOURCE
      SOURCE #countLoops
        #public client server static Integer countLoops(QueryRun _queryRun)
        #{
        #    container c = SysQuery::countPrim(_queryRun.pack(false));
        #
        #    return conPeek(c,2);
        #}
      ENDSOURCE
      SOURCE #countPrim
        #private server static container countPrim(container _queryPack)
        #{
        #    Query                   countQuery;
        #    QueryRun                countQueryRun;
        #    QueryBuildDataSource    qbds;
        #    QueryBuildFieldList     qbfl;
        #    Common                  common;
        #    Integer                 counter;
        #    Integer                 loops;
        #    ;
        #    countQueryRun   = new QueryRun(_queryPack);
        #    countQuery      = countQueryRun.query();
        #    qbds            = countQuery.dataSourceNo(1);
        #    qbds.update(false);
        #    qbds.sortClear();
        #    countQuery.clearGroupBy();
        #    countQuery.clearOrderBy();
        #    qbfl = qbds.fields();
        #    qbfl.dynamic(false);
        #    qbfl.clearFieldList();
        #    if (countQuery.dataSourceCount() == 1)
        #        qbds.addSelectionField(fieldNum(Common,RecId),SelectionField::Count);
        #
        #    countQueryRun   = new QueryRun(countQuery);
        #
        #    while (countQueryRun.next())
        #    {
        #        common  = countQueryRun.get(countQuery.dataSourceNo(1).table());
        #        counter += common.RecId;
        #        loops++;
        #    }
        #
        #    return [counter,loops];
        #}
      ENDSOURCE
      SOURCE #countPrimClient
        #client static int countPrimClient(Query _query)
        #{
        #    Query                   countQuery;
        #    QueryRun                countQueryRun;
        #    QueryBuildDataSource    qbds;
        #    QueryBuildFieldList     qbfl;
        #    Common                  common;
        #    int                     counter;
        #    int                     loops;
        #    int                     iGrp;
        #    int                     k
        #  ;
        #    countQueryRun   = new QueryRun(_query);
        #    countQuery      = countQueryRun.query();
        #    for (k = 1; k <= countQuery.dataSourceCount();k++)
        #    {
        #        qbds = countQuery.dataSourceNo(k);
        #        qbds.update(false);
        #        iGrp +=(qbds.orderMode()==orderMode::GroupBy); // SHiSHok.fix
        #        //qbds.sortClear(); // Вот этот метод сильно мешал!
        #        qbfl = qbds.fields();
        #        qbfl.dynamic(false);
        #        qbfl.clearFieldList();
        #        qbfl.addField(FieldNum(Common,recId),SelectionField::COUNT);
        #    }
        #
        #    countQueryRun   = new QueryRun(countQuery);
        #    while (countQueryRun.next())
        #    {
        #        common  = countQueryRun.getNo(1);
        #        counter += common.recId;
        #        loops++;
        #    }
        #//    return [counter,((loops > 1)? loops : counter)];
        #    return counter;
        #}
      ENDSOURCE
      SOURCE #countTotal
        #public client server static Integer countTotal(QueryRun _queryRun)
        #{
        #    container c = SysQuery::countPrim(_queryRun.pack(false));
        #
        #    return conPeek(c,1);
        #}
      ENDSOURCE
      SOURCE #deleteDynalinks
        #/*
        #Deletes ranges in Q which is in InitQ.
        #*/
        #public static void deleteDynalinks(Query q, Query initQ, int initQdsNo = 1)
        #{
        #    QueryBuildRange     toQbr;
        #    QueryBuildDynalink  dyna;
        #    Counter             fromI = 1;
        #    FieldId             id;
        #    int                 qdsNo = initQdsNo;
        #    Counter             toI;
        #
        #    if (! initQ.dataSourceNo(initQdsNo))
        #        throw error(strFmt("@SYS23667",funcName()));
        #
        #    if (! q)
        #        throw error(strFmt("@SYS23669",funcName()));
        #
        #    if (! q.dataSourceNo(1))
        #        throw error(strFmt("@SYS23667",funcName()));
        #
        #    if (q.dataSourceCount() >= initQdsNo)
        #    {
        #        if (q.dataSourceNo(initQdsNo).file() != initQ.dataSourceNo(initQdsNo).file())
        #        {
        #               throw error(strFmt("@SYS23668",funcName()));
        #        }
        #    }
        #
        #    if (! initQ)
        #        return;
        #
        #    fromI = 1;
        #    while (fromI <= initQ.dataSourceNo(initQdsNo).dynalinkCount())
        #    {
        #        dyna    = initQ.dataSourceNo(initQdsNo).dynalink(fromI);
        #        id      = dyna.field();
        #        toQbr   = null;
        #        if (q.dataSourceNo(qdsNo).findRange(id))
        #        {
        #            toI = 1;
        #            while (toI)
        #            {
        #                toQbr  = q.dataSourceNo(qdsNo).findRange(id,toI);
        #
        #                if (! toQbr)
        #                    break;
        #
        #                // If To and From values are equal then emthy range
        #                if (toQbr.value() && toQbr.value() == dyna.cursor().(dyna.dynamicField()))
        #                    toQbr.value('');
        #
        #                toI++;
        #            }
        #        }
        #
        #        fromI++;
        #    }
        #}
      ENDSOURCE
      SOURCE #disabledDataSourceSet
        #public static Set disabledDataSourceSet(Query _query)
        #{
        #    Set                  disabledDataSourceSet   = new Set(Types::Integer);
        #    QueryBuildDataSource queryBuildDataSource;
        #    Counter              dataSourceCnt           = _query.dataSourceCount();
        #    Counter              childCnt;
        #    int                  i;
        #
        #
        #    for (i=1; i<=dataSourceCnt; i++)
        #    {
        #        queryBuildDataSource = _query.dataSourceNo(i);
        #        if (!disabledDataSourceSet.in(queryBuildDataSource.uniqueId()) &&
        #            !queryBuildDataSource.enabled())
        #        {
        #            disabledDataSourceSet.add(queryBuildDataSource.uniqueId());
        #
        #            childCnt = queryBuildDataSource.childDataSourceCount();
        #            if (childCnt)
        #            {
        #                SysQuery::disabledDataSourceSetChildren(disabledDataSourceSet, queryBuildDataSource, childCnt);
        #            }
        #        }
        #    }
        #
        #    return disabledDataSourceSet;
        #}
      ENDSOURCE
      SOURCE #disabledDataSourceSetChildren
        #private static void disabledDataSourceSetChildren(Set _disabledDataSourceSet, QueryBuildDataSource _queryBuildDataSource, Counter _childCnt)
        #{
        #    QueryBuildDataSource childDataSource;
        #    int                  i;
        #    Counter              counter;
        #
        #    for (i=1; i<=_childCnt; i++)
        #    {
        #        childDataSource = _queryBuildDataSource.childDataSourceNo(i);
        #        _disabledDataSourceSet.add(childDataSource.uniqueId());
        #
        #        counter = childDataSource.childDataSourceCount();
        #        if (counter)
        #        {
        #            SysQuery::disabledDataSourceSetChildren(_disabledDataSourceSet, childDataSource, counter);
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #findOrCreateDataSource
        #/// <summary>
        #/// Finds or creates a QueryBuildDataSource from the given parameters.
        #/// </summary>
        #/// <param name="_query">
        #/// The query to find or create the QueryBuildDataSource in.
        #/// </param>
        #/// <param name="_tableId">
        #/// The Id of the table for the QueryBuildDataSource.
        #/// </param>
        #/// <param name="_parentTableId">
        #/// The Id of the table under which to create the QueryBuildDataSource if it isn't found.
        #/// </param>
        #/// <returns>
        #/// The found or newly created QueryBuildDataSource.
        #/// </returns>
        #public static QueryBuildDataSource findOrCreateDataSource(Query _query, TableId _tableId, TableId _parentTableId = 0)
        #{
        #    QueryBuildDataSource    queryBuildDataSource;
        #    QueryBuildDataSource    parentDataSource;
        #
        #    if (_query)
        #    {
        #        queryBuildDataSource = _query.dataSourceTable(_tableId);
        #
        #        if (!queryBuildDataSource)
        #        {
        #            if (_parentTableId)
        #            {
        #                parentDataSource = _query.dataSourceTable(_parentTableId);
        #
        #                if (parentDataSource)
        #                {
        #                    queryBuildDataSource = parentDataSource.addDataSource(_tableId);
        #                }
        #            }
        #            else
        #            {
        #                queryBuildDataSource = _query.addDataSource(_tableId);
        #            }
        #        }
        #    }
        #    return queryBuildDataSource;
        #}
      ENDSOURCE
      SOURCE #findOrCreateDataSourceByName
        #/// <summary>
        #/// Finds or creates a QueryBuildDataSource from the given QueryBuildDataSourceName.
        #/// </summary>
        #/// <param name="query">
        #/// The query to find or create the QueryBuildDataSource in.
        #/// </param>
        #/// <param name="queryBuildDataSourceName">
        #/// The name of the QueryBuildDataSource to find or create.
        #/// </param>
        #/// <param name="tableId">
        #/// The Id of the table for the QueryBuildDataSource. Used to ensure the correct type of QueryBuildDataSource is found.
        #/// </param>
        #/// <param name="parentQueryBuildDataSourceName">
        #/// The name of the parent QueryBuildDataSource under which to create the new QueryBuildDataSource if it is not found.
        #/// </param>
        #/// <param name="parentTableId">
        #/// The Id of the table under which to create the QueryBuildDataSource. Used to ensure the correct type of parent QueryBuildDataSource is found.
        #/// </param>
        #/// <param name="emptyFieldList">
        #/// Specifies whether or not the datasource should have an empty field list when it is created.  This parameter does not modify
        #/// an existing datasource if it one was found.
        #/// </param>
        #/// <returns>
        #/// The found or newly created QueryBuildDataSource.
        #/// </returns>
        #/// <remarks>
        #/// This API will search for the QueryBuildDataSource(s) by name.  If found it will ensure the QueryBuildDataSource is of
        #/// the expected tableid, if not, null will be returned.  If not found, a new QueryBuildDataSoure will be created with the
        #/// given name and table id. If the parentQueryBuildDataSourceName is specied, then the datasource will be created under
        #/// that specific parent datasource.  If that parent datasource cannot be found, then one is not created.  Note: The
        #/// parentTableId is used to verify the correct parent table type as well.
        #/// </remarks>
        #public static QueryBuildDataSource findOrCreateDataSourceByName(Query query, str queryBuildDataSourceName, TableId tableId, str parentQueryBuildDataSourceName = '', TableId parentTableId = 0, boolean emptyFieldList = false)
        #{
        #    QueryBuildDataSource    queryBuildDataSource;
        #    QueryBuildDataSource    parentQueryBuildDataSource;
        #
        #    if (query)
        #    {
        #        queryBuildDataSource = query.dataSourceName(queryBuildDataSourceName);
        #
        #        if (!queryBuildDataSource)
        #        {
        #            if(parentQueryBuildDataSourceName)
        #            {
        #                parentQueryBuildDataSource = query.dataSourceName(parentQueryBuildDataSourceName);
        #
        #                if(parentQueryBuildDataSource && parentQueryBuildDataSource.table() == parentTableId)
        #                {
        #                    queryBuildDataSource = parentQueryBuildDataSource.addDataSource(tableId, queryBuildDataSourceName, emptyFieldList);
        #                }
        #            }
        #            else
        #            {
        #                //No parent datasource specified, create at the root.
        #                queryBuildDataSource = query.addDataSource(tableId, queryBuildDataSourceName, UnionType::Union, emptyFieldList);
        #            }
        #        }
        #        else if(queryBuildDataSource && queryBuildDataSource.table() != tableId)
        #        {
        #            //If the tableIds don't match, then return null as the correct one wasn't found.
        #            queryBuildDataSource = null;
        #        }
        #    }
        #
        #    return queryBuildDataSource;
        #}
      ENDSOURCE
      SOURCE #findOrCreateQueryFilter
        #/// <summary>
        #/// Finds or creates a QueryFilter from the given parameters.
        #/// </summary>
        #/// <param name="query">
        #/// The query to find or create the QueryFilter in.
        #/// </param>
        #/// <param name="queryBuildDataSource">
        #/// The QueryBuildDataSource to find or add the QueryFilter on.
        #/// </param>
        #/// <param name="fieldName">
        #/// The name of the field to find or add the QueryFilter for.
        #/// </param>
        #/// <param name="occurrence">
        #/// The occurrence of the field in the QueryFilter list, defaults to the first.
        #/// </param>
        #/// <param name="arrayIndex">
        #/// The array index for the given fieldname, defaults to 1.
        #/// </param>
        #/// <returns>
        #/// A found or newly created QueryFilter from the given parameters.
        #/// </returns>
        #public static QueryFilter findOrCreateQueryFilter(Query query,
        #    QueryBuildDataSource queryBuildDataSource,
        #    FieldName fieldName,
        #    int occurrence = 1,
        #    int arrayIndex = 1)
        #{
        #    QueryFilter queryFilter;
        #
        #    if (query)
        #    {
        #        queryFilter = query.findQueryFilter(queryBuildDataSource, fieldName, occurrence, arrayIndex);
        #
        #        if (!queryFilter)
        #        {
        #            queryFilter = query.addQueryFilter(queryBuildDataSource, fieldName, arrayIndex);
        #        }
        #    }
        #
        #    return queryFilter;
        #}
      ENDSOURCE
      SOURCE #findOrCreateRange
        #public static QueryBuildRange findOrCreateRange(QueryBuildDataSource _queryBuildDataSource,
        #    FieldId _fieldId,
        #    int _occurrence = 1,
        #    int _arrayIndex = fieldExt2Idx(_fieldId))
        #{
        #    QueryBuildRange queryBuildRange;
        #
        #    if (_queryBuildDataSource)
        #    {
        #        queryBuildRange = _queryBuildDataSource.findRange(_fieldId, _occurrence, _arrayIndex);
        #
        #        if (!queryBuildRange)
        #        {
        #            queryBuildRange = _queryBuildDataSource.addRange(_fieldId, _arrayIndex);
        #        }
        #    }
        #
        #    return queryBuildRange;
        #}
      ENDSOURCE
      SOURCE #findSortingNo_W
        #public static int findSortingNo_W(QueryBuildDataSource _queryBuildDataSource, FieldId _fieldId)
        #{
        #    Counter sortfieldCount = _queryBuildDataSource.sortFieldCount();
        #    int     i;
        #    int     sortingNo;
        #
        #    for (i = 1; i <= sortfieldCount && !sortingNo; i++)
        #    {
        #        if (_fieldId == _queryBuildDataSource.sortField(i))
        #        {
        #            sortingNo = i;
        #        }
        #    }
        #    return sortingNo;
        #}
      ENDSOURCE
      SOURCE #findTargetQueryFilter
        #private static QueryFilter findTargetQueryFilter(
        #    Query _sourceQuery,
        #    Query _targetQuery,
        #    QueryFilter _sourceQueryFilter,
        #    int _targetQueryDataSourceIndex,
        #    FieldName _fieldName,
        #    ArrayIdx _arrayIndex,
        #    boolean _doNotAddQueryFilterForSameField)
        #{
        #    DictField dictField;
        #    QueryBuildDataSource targetDataSource;
        #    QueryFilter targetQueryFilter;
        #    TableId tableId;
        #    FieldId fieldId;
        #    int filterIndex;
        #
        #    targetQueryFilter = null;
        #    targetDataSource = _targetQuery.dataSourceNo(_targetQueryDataSourceIndex);
        #
        #    tableId = targetDataSource.table();
        #    fieldId = fieldName2id(tableId, _fieldName);
        #    dictField = new DictField(tableId, fieldId);
        #
        #    if ((dictField.arraySize() > 1 && _targetQuery.findQueryFilter(targetDataSource, _fieldName, 1, _arrayIndex) != null) ||
        #        (dictField.arraySize() <= 1 && _targetQuery.findQueryFilter(targetDataSource, _fieldName) != null))
        #    {
        #        if (_doNotAddQueryFilterForSameField)
        #        {
        #            // a filter for the field was found, do nothing
        #            return null;
        #        }
        #
        #        filterIndex = 1;
        #        while (filterIndex)
        #        {
        #            if (dictField.arraySize() > 1)
        #            {
        #                targetQueryFilter = _targetQuery.findQueryFilter(targetDataSource, dictField.name(), filterIndex, _arrayIndex);
        #            }
        #            else
        #            {
        #                targetQueryFilter = _targetQuery.findQueryFilter(targetDataSource, dictField.name(), filterIndex);
        #            }
        #
        #            if (targetQueryFilter == null)
        #            {
        #                break;
        #            }
        #
        #            // If To value is empty, use it later
        #            if (targetQueryFilter.value() == '')
        #            {
        #                break;
        #            }
        #
        #            // If To and From values are equal then add new filter later
        #            if (targetQueryFilter.value() == _sourceQueryFilter.value())
        #            {
        #                break;
        #            }
        #
        #            filterIndex++;
        #        }
        #    }
        #
        #    if (targetQueryFilter == null||
        #        (!_doNotAddQueryFilterForSameField &&
        #        targetQueryFilter != null &&
        #        targetQueryFilter.value() &&
        #        _sourceQueryFilter.value() &&
        #        targetQueryFilter.value() != _sourceQueryFilter.value()))
        #    {
        #        if (dictField.arraySize() > 1)
        #        {
        #            targetQueryFilter = _targetQuery.addQueryFilter(targetDataSource, dictField.name(), _arrayIndex);
        #        }
        #        else
        #        {
        #            targetQueryFilter = _targetQuery.addQueryFilter(targetDataSource, dictField.name());
        #        }
        #    }
        #
        #    return targetQueryFilter;
        #}
        #
      ENDSOURCE
      SOURCE #getDimComponentAttAndFieldFromOrderBy
        #/// <summary>
        #/// Determines the dimension component being sorted by.
        #/// </summary>
        #/// <param name="_orderByField">
        #/// The <c>QueryOrderByField</c> object associated to a dimension component.
        #/// </param>
        #/// <returns>
        #/// A <c>container</c> that contains sthe dimension component being sorted by.
        #/// </returns>
        #public static container getDimComponentAttAndFieldFromOrderBy(QueryOrderByField _orderByField)
        #{
        #    QueryBuildDataSource    orderByDataSource = _orderByField.dataSource();
        #    Range                   dimensionAttributeRange;
        #    Name                    dimensionAttributeName;
        #    FieldName               dimensionField;
        #    DimensionComponent      dimensionComponent;
        #    int                     i;
        #    QueryBuildLink          queryLink;
        #
        #    switch (orderByDataSource.table())
        #    {
        #        case tableNum(DimensionHierarchy):
        #            dimensionComponent = DimensionComponent::AccountStructure;
        #            break;
        #        case tableNum(DimensionAttributeLevelValueView):
        #            dimensionAttributeRange = orderByDataSource.findRange(fieldNum(DimensionAttributeLevelValueView, DimensionAttribute)).value();
        #            if (dimensionAttributeRange)
        #            {
        #                dimensionAttributeName = DimensionAttribute::find(str2int64(dimensionAttributeRange)).Name;
        #                dimensionComponent = DimensionComponent::DimensionAttribute;
        #            }
        #            else
        #            {
        #                dimensionComponent = DimensionComponent::LedgerDimensionDisplayValue;
        #            }
        #            break;
        #        case tableNum(DimensionAttributeValueSetItemView):
        #            dimensionAttributeRange = orderByDataSource.findRange(fieldNum(DimensionAttributeValueSetItemView, DimensionAttribute)).value();
        #            if (dimensionAttributeRange)
        #            {
        #                dimensionAttributeName = DimensionAttribute::find(str2int64(dimensionAttributeRange)).Name;
        #                dimensionComponent = DimensionComponent::DimensionAttribute;
        #            }
        #            break;
        #        case tableNum(DimensionAttributeSetItem):
        #            dimensionAttributeRange = orderByDataSource.findRange(fieldNum(DimensionAttributeSetItem, DimensionAttribute)).value();
        #            if (dimensionAttributeRange)
        #            {
        #                dimensionAttributeName = DimensionAttribute::find(str2int64(dimensionAttributeRange)).Name;
        #                dimensionComponent = DimensionComponent::DimensionAttribute;
        #            }
        #            break;
        #        default:
        #            // Unknown case
        #            Debug::assert(false);
        #            break;
        #    }
        #
        #    // Use the link from the orderby datasource back to the parent datasource
        #    // to figure out which field on the parent datasource is the dimension field
        #    for (i = 1; i <= orderByDataSource.linkCount(); i++)
        #    {
        #        queryLink = orderByDataSource.link(i);
        #        if (queryLink.table() == orderByDataSource.parentDataSource().table())
        #        {
        #            dimensionField = fieldId2name(queryLink.table(), queryLink.field());
        #            break;
        #        }
        #    }
        #
        #    return [dimensionComponent, dimensionAttributeName, dimensionField];
        #}
      ENDSOURCE
      SOURCE #getDimensionAttributeValLocFromQueryRun
        #/// <summary>
        #///    Retrieves the location of the value of the specified dimension from the <c>QueryRun</c> object and authorization
        #///    information.
        #/// </summary>
        #/// <param name="_queryRun">
        #///    The <c>QueryRun</c> object that contains the results.
        #/// </param>
        #/// <param name="_dataSourceName">
        #///    The name of the root data source in the query that references dimension information.
        #/// </param>
        #/// <param name="_dimensionFieldName">
        #///    The name of the field in the root data source in the query that references dimension information.
        #/// </param>
        #/// <param name="_dimensionComponent">
        #///    The dimension component within the dimension information to pivot.
        #/// </param>
        #/// <param name="_dimensionAttributeName">
        #///    The name of the dimension attribute for which a value should be retrieved.
        #/// </param>
        #/// <returns>
        #///    A container consisting of the data source number and field ID containing the dimension value.
        #/// </returns>
        #/// <remarks>
        #///    The instance of the <c>QueryRun</c> object must contain the values that are being searched for as
        #///    columns. This can be done by calling the <c>addDimensionDataSourceToQuery</c> method before the
        #///    query is executed.If it does not exist, an exception will be thrown. If the dimension attribute
        #///    name is not specified the denormalized combination string for the ledger dimension is returned.
        #/// </remarks>
        #public static container getDimensionAttributeValLocFromQueryRun(QueryRun _queryRun, str _dataSourceName, str _dimensionFieldName, DimensionComponent _dimensionComponent, str _dimensionAttributeName = '')
        #{
        #    DimensionProviderBase provider;
        #
        #    provider = SysQuery::getDimensionProviderFromFieldInQuery(_queryRun.query(), _dataSourceName, _dimensionFieldName);
        #    if (provider)
        #    {
        #        return provider.getAttributeValueLocFromQueryRun(_queryRun, _dataSourceName, _dimensionFieldName, _dimensionComponent, _dimensionAttributeName);
        #    }
        #
        #    throw error(Error::missingOverride(classStr(DimensionProviderBase)));
        #}
      ENDSOURCE
      SOURCE #getDimensionAttributeValNameFromQueryRun
        #/// <summary>
        #///    Retrieves the description of the specified dimension from the <c>QueryRun</c> object and authorization
        #///    information.
        #/// </summary>
        #/// <param name="_queryRun">
        #///    The <c>QueryRun</c> object that contains the results.
        #/// </param>
        #/// <param name="_dataSourceName">
        #///    The name of the root data source in the query that references dimension information.
        #/// </param>
        #/// <param name="_dimensionFieldName">
        #///    The name of the field in the root data source in the query that references dimension information.
        #/// </param>
        #/// <param name="_dimensionComponent">
        #///    The dimension information being pivoted.
        #/// </param>
        #/// <param name="_dimensionAttributeName">
        #///    The name of the dimension attribute for which a description should be retrieved.
        #/// </param>
        #/// <returns>
        #///    The string description of the specified dimension.
        #/// </returns>
        #/// <remarks>
        #///    The instance of the <c>QueryRun</c> object must contain the values that are being searched for as
        #///    columns. This can be done by calling the <c>addDimensionDataSourceToQuery</c> method before the
        #///    query is executed.If it does not exist, an exception will be thrown. If the dimension attribute
        #///    name is not specified the denormalized combination string for the ledger dimension is returned.
        #/// </remarks>
        #public static container getDimensionAttributeValNameFromQueryRun(QueryRun _queryRun, str _dataSourceName, str _dimensionFieldName, DimensionComponent _dimensionComponent, str _dimensionAttributeName = '')
        #{
        #    DimensionProviderBase provider;
        #
        #    provider = SysQuery::getDimensionProviderFromFieldInQuery(_queryRun.query(), _dataSourceName, _dimensionFieldName);
        #    if (provider)
        #    {
        #        return provider.getAttributeValueNameFromQueryRun(_queryRun, _dataSourceName, _dimensionFieldName, _dimensionComponent, _dimensionAttributeName);
        #    }
        #
        #    throw error(Error::missingOverride(classStr(DimensionProviderBase)));
        #}
      ENDSOURCE
      SOURCE #getDimensionAttributeValueFromQueryRun
        #/// <summary>
        #///    Retrieves the value of the specified dimension from the <c>QueryRun</c> object and authorization
        #///    information.
        #/// </summary>
        #/// <param name="_queryRun">
        #///    The <c>QueryRun</c> object that contains the results.
        #/// </param>
        #/// <param name="_dataSourceName">
        #///    The name of the root data source in the query that references dimension information.
        #/// </param>
        #/// <param name="_dimensionFieldName">
        #///    The name of the field in the root data source in the query that references dimension information.
        #/// </param>
        #/// <param name="_dimensionComponent">
        #///    The dimension component within the dimension information to pivot.
        #/// </param>
        #/// <param name="_dimensionAttributeName">
        #///    The name of the dimension attribute for which a value should be retrieved.
        #/// </param>
        #/// <returns>
        #///    The string or enumeration value of the specified dimension.
        #/// </returns>
        #/// <remarks>
        #///    The instance of the <c>QueryRun</c> object must contain the values that are being searched for as
        #///    columns. This can be done by calling the <c>addDimensionDataSourceToQuery</c> method before the
        #///    query is executed.If it does not exist, an exception will be thrown. If the dimension attribute
        #///    name is not specified the denormalized combination string for the ledger dimension is returned.
        #/// </remarks>
        #public static container getDimensionAttributeValueFromQueryRun(QueryRun _queryRun, str _dataSourceName, str _dimensionFieldName, DimensionComponent _dimensionComponent, str _dimensionAttributeName = '')
        #{
        #    DimensionProviderBase provider;
        #
        #    provider = SysQuery::getDimensionProviderFromFieldInQuery(_queryRun.query(), _dataSourceName, _dimensionFieldName);
        #    if (provider)
        #    {
        #        return provider.getAttributeValueFromQueryRun(_queryRun, _dataSourceName, _dimensionFieldName, _dimensionComponent, _dimensionAttributeName);
        #    }
        #
        #    throw error(Error::missingOverride(classStr(DimensionProviderBase)));
        #}
      ENDSOURCE
      SOURCE #getDimensionOrderBysFromQuery
        #/// <summary>
        #///    Gets the list of dimension ranges in a query.
        #/// </summary>
        #/// <param name="_query">
        #///    The input query.
        #/// </param>
        #/// <returns>
        #///    The list of dimension ranges in a query.
        #/// </returns>
        #public static List getDimensionOrderBysFromQuery(Query _query)
        #{
        #    List                    list;
        #    ListEnumerator          listEnum;
        #    DimensionProviderBase   providerClass;
        #    List                    orderByList = new List(Types::Container);
        #    List                    ret = new List(Types::Container);
        #
        #    list = SysDictType::getAllDimensionProviders();
        #    listEnum = list.getEnumerator();
        #    while (listEnum.moveNext())
        #    {
        #        providerClass = listEnum.current();
        #        orderByList = providerClass.getDimensionOrderBysFromQuery(_query);
        #        ret.appendList(orderByList);
        #    }
        #    return orderByList;
        #}
      ENDSOURCE
      SOURCE #getDimensionProviderFromFieldInQuery
        #/// <summary>
        #///    Gets the dimension provider for the specified field in the query.
        #/// </summary>
        #/// <param name="_query">
        #///    The query to update.
        #/// </param>
        #/// <param name="_dataSourceName">
        #///    The name of the root data source in the query that references the dimension information.
        #/// </param>
        #/// <param name="_dimensionFieldName">
        #///    The name of the field in the root data source in the query that references the dimension
        #///    information.
        #/// </param>
        #/// <returns>
        #///    The dimension provider for the specified field.
        #/// </returns>
        #private static DimensionProviderBase getDimensionProviderFromFieldInQuery(Query _query, str _dataSourceName, str _dimensionFieldName)
        #{
        #    QueryBuildDataSource    qbds;
        #    DimensionProviderBase   retProvider = null;
        #    DictField               dictField;
        #    SysDictType             dictType;
        #    FieldId                 dimensionFieldId;
        #    TableId                 qbdsTable;
        #
        #    // Find the specified data source
        #    qbds = _query.dataSourceName(_dataSourceName);
        #
        #    if (qbds)
        #    {
        #        qbdsTable = qbds.table();
        #
        #        dimensionFieldId = fieldName2id(qbdsTable, _dimensionFieldName);
        #        dictField = new DictField(qbdsTable, dimensionFieldId);
        #        dictType = new SysDictType(dictField.typeId());
        #        if (dictType)
        #        {
        #            retProvider = dictType.getDimensionProvider();
        #        }
        #    }
        #
        #    return retProvider;
        #}
      ENDSOURCE
      SOURCE #getDimensionRangesFromQuery
        #/// <summary>
        #///    Gets the list of dimension ranges in a query.
        #/// </summary>
        #/// <param name="_query">
        #///    The input query.
        #/// </param>
        #/// <returns>
        #///    The list of dimension ranges in a query.
        #/// </returns>
        #public static List getDimensionRangesFromQuery(Query _query)
        #{
        #    List                    list;
        #    ListEnumerator          listEnum;
        #    DimensionProviderBase   providerClass;
        #    List                    rangeList = new List(Types::Container);
        #    List                    ret = new List(Types::Container);
        #
        #    list = SysDictType::getAllDimensionProviders();
        #    listEnum = list.getEnumerator();
        #    while (listEnum.moveNext())
        #    {
        #        providerClass = listEnum.current();
        #        rangeList = providerClass.getDimensionRangesFromQuery(_query);
        #        ret.appendList(rangeList);
        #    }
        #    return rangeList;
        #}
      ENDSOURCE
      SOURCE #getDimensionStringValueFromCursor
        #/// <summary>
        #/// Gets a string that represents the concatenated dimension information from the specified field.
        #/// </summary>
        #/// <param name="_query">
        #/// The query to update.
        #/// </param>
        #/// <param name="_cursor">
        #/// The pointer that contains the dimension information.
        #/// </param>
        #/// <param name="_dimensionFieldName">
        #/// The name of the field that contains dimension information.
        #/// </param>
        #/// <returns>
        #/// A denormalized dimension string value.
        #/// </returns>
        #/// <remarks>
        #/// This method is only applicable for ledger dimensions, as you cannot generate a correct concatenated
        #/// display string for dimension enumerations or default dimensions.
        #/// </remarks>
        #public static DimensionDisplayValue getDimensionStringValueFromCursor(Query _query, Common _cursor, str _dimensionFieldName)
        #{
        #    DimensionDisplayValue ret;
        #    DimensionProviderBase provider;
        #    TableId tableId = _cursor.tableId();
        #    SysDictField dictField = new SysDictField(tableId,fieldName2id(tableId,_dimensionFieldName));
        #    SysDictType dictType = new SysDictType(dictField.typeId());
        #
        #    provider = dictType.getDimensionProvider();
        #
        #    if (provider)
        #        ret = provider.getStringValueFromCursor(_cursor,_dimensionFieldName);
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getValueQueryForDimensionAttribute
        #/// <summary>
        #///    Gets a query for the specified table with a pivoted column for the specified dimension.
        #/// </summary>
        #/// <param name="_parentTable">
        #///    The parent table that contains the dimension information.
        #/// </param>
        #/// <param name="_dimensionFieldId">
        #///    The name of the field on the parent table that contains the dimension information.
        #/// </param>
        #/// <param name="_dimensionComponent">
        #///    The dimension component within the dimension information to pivot.
        #/// </param>
        #/// <param name="_dimensionAttributeName">
        #///    The name of the dimension attribute to join with the parent data source to pivot the dimension
        #///    information.
        #/// </param>
        #/// <returns>
        #///    A query with a root data source that is bound to the specified table with the dimension information
        #///    pivoted as a joined data source.
        #/// </returns>
        #/// <remarks>
        #///    If no dimension attribute is specified and the field is a ledger dimension, the denormalized
        #///    combination string for the dimension information will be joined instead.
        #/// </remarks>
        #public static Query getValueQueryForDimensionAttribute(str _parentTable, FieldId _dimensionFieldId, DimensionComponent _dimensionComponent, str _dimensionAttributeName = '')
        #{
        #    DimensionProviderBase provider;
        #    SysDictType dictType;
        #    SysDictField dictField;
        #    Query ret;
        #
        #    dictField = new SysDictField(tableName2id(_parentTable),_dimensionFieldId);
        #    if (dictField)
        #    {
        #        dictType = new SysDictType(dictField.typeId());
        #        if (dictType)
        #        {
        #            provider = dictType.getDimensionProvider();
        #            if (provider)
        #            {
        #                ret = provider.getValueQueryForDimensionAttribute(_parentTable, _dimensionFieldId, _dimensionComponent, _dimensionAttributeName);
        #            }
        #        }
        #    }
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #hasIndexImplicit
        #/// <summary>
        #/// Ensure if index field has field name matches with one provided
        #/// </summary>
        #/// <param name="_dictTable">
        #/// The <c>DictTalbe</c> class of the current <c>QueryBuilDataSource</c> class.
        #/// </param>
        #/// <param name="_fieldName">
        #/// Field name of query filter or range.
        #/// </param>
        #/// <returns>
        #/// true if index field name matches with the one provided; otherwise, false
        #/// </returns>
        #private static boolean hasIndexImplicit(DictTable _dictTable, FieldName _fieldName)
        #{
        #    SysDictField            sysDictField;
        #    DictTable               dictTable;
        #    DictIndex               dictIndex;
        #    Counter                 indexCnt;
        #    TableId                 tableId;
        #    int                     numberOfIndexFields;
        #    int                     currentField    = 1;
        #    boolean                 hasIndexImplicit = false;
        #    FieldName               indexFieldName;
        #    ;
        #
        #    dictTable   = _dictTable;
        #    tableId = dictTable.id();
        #
        #    for (indexCnt = 0; indexCnt < dictTable.indexCnt(); indexCnt++)
        #    {
        #        dictIndex = dictTable.indexObject(dictTable.indexNext(indexCnt));
        #        if (dictIndex.enabled())
        #            break;
        #    }
        #
        #    if (dictIndex)
        #    {
        #        numberOfIndexFields = dictIndex.numberOfFields();
        #        for(currentField  = 1;currentField <= numberOfIndexFields; currentField++)
        #        {
        #            sysDictField = new SysDictField(tableId,dictIndex.field(currentField));
        #            indexFieldName = sysDictField.name();
        #            if(indexFieldName == _fieldName)
        #            {
        #                hasIndexImplicit = true;
        #                break;
        #            }
        #        }
        #    }
        #
        #    return hasIndexImplicit;
        #}
      ENDSOURCE
      SOURCE #hasIndexImplicitFilter
        #/// <summary>
        #/// Validates that the index field has an implicit query filter applied.
        #/// </summary>
        #/// <param name="_queryBuildDataSource">
        #/// The <c>QueryBuilDataSource</c> that has indexes that will be used for comparison.
        #/// </param>
        #/// <param name="_queryFilterFieldName">
        #/// Field name of the query filter.
        #/// </param>
        #/// <returns>
        #/// true if index has filter applied; otherwise, false.
        #/// </returns>
        #private static boolean hasIndexImplicitFilter(QueryBuildDataSource _queryBuildDataSource, FieldName _queryFilterFieldName)
        #{
        #    DictTable               dictTable;
        #    TableId                 tableId;
        #    boolean                 hasIndexImplicitFilter = false;
        #    ;
        #
        #    tableId     = _queryBuildDataSource.table();
        #    dictTable   = new DictTable(tableId);
        #
        #    hasIndexImplicitFilter = SysQuery::hasIndexImplicit(dictTable,_queryFilterFieldName);
        #
        #    return hasIndexImplicitFilter;
        #
        #}
      ENDSOURCE
      SOURCE #hasIndexImplicitRange
        #/// <summary>
        #/// Validates that the index field has an implicit query build range applied.
        #/// </summary>
        #/// <param name="_queryBuildRange">
        #/// The <c>QueryBuildRange</c> class that has indexes that will be used for comparison.
        #/// </param>
        #/// <returns>
        #/// true if index has range applied; otherwise, false.
        #/// </returns>
        #private static boolean hasIndexImplicitRange(QueryBuildRange _queryBuildRange)
        #{
        #    DictTable               dictTable;
        #    TableId                 tableId;
        #    boolean                 hasIndexImplicitRange = false;
        #    ;
        #
        #    tableId     = _queryBuildRange.table();
        #    dictTable   = new DictTable(tableId);
        #
        #    hasIndexImplicitRange = SysQuery::hasIndexImplicit(dictTable,_queryBuildRange.fieldName());
        #
        #    return hasIndexImplicitRange;
        #}
      ENDSOURCE
      SOURCE #hasSurrogateFKImplicitFilter
        #/// <summary>
        #/// Validates that the field identifier has an implicit query filter applied.
        #/// </summary>
        #/// <param name="_queryBuildDataSource">
        #/// The <c>QueryBuilDataSource</c> class that has indexes that will be used for comparison.
        #/// </param>
        #/// <param name="_queryFilterFieldName">
        #/// The field name of query filter
        #/// </param>
        #/// <returns>
        #/// true if field identifier has filter applied; otherwise false.
        #/// </returns>
        #private static boolean hasSurrogateFKImplicitFilter(QueryBuildDataSource _queryBuildDataSource, FieldName _queryFilterFieldName)
        #{
        #    boolean     hasImplicitSurrogateFK = false;
        #    DictTable   dictTable;
        #    DictField   dictField;
        #    TableId     tableId;
        #
        #    int         fieldPos;
        #
        #    tableId = _queryBuildDataSource.table();
        #    dictTable = new DictTable(tableId);
        #    if(dictTable)
        #    {
        #        fieldPos = dictTable.fieldNext(fieldPos);
        #        while(fieldPos)
        #        {
        #            dictField = dictTable.fieldObject(fieldPos);
        #            if(dictField && dictField.isSurrogateForeignKey())
        #            {
        #                if(dictField.name() == _queryFilterFieldName)
        #                {
        #                    hasImplicitSurrogateFK = true;
        #                    break;
        #                }
        #            }
        #            fieldPos = dictTable.fieldNext(fieldPos);
        #        }
        #    }
        #
        #
        #    return hasImplicitSurrogateFK;
        #}
      ENDSOURCE
      SOURCE #isDimensionDataSource
        #/// <summary>
        #///    Gets a value that indicates whether a data source is a dimension data source.
        #/// </summary>
        #/// <param name="_qbds">
        #///    The input data source.
        #/// </param>
        #/// <returns>
        #///    true if the input data source is a dimension data source; otherwise, false.
        #/// </returns>
        #public static boolean isDimensionDataSource(QueryBuildDataSource _qbds)
        #{
        #    List                    list;
        #    ListEnumerator          listEnum;
        #    DimensionProviderBase   providerClass;
        #
        #    if (_qbds.embedded())
        #    {
        #        list = SysDictType::getAllDimensionProviders();
        #        listEnum = list.getEnumerator();
        #        while (listEnum.moveNext())
        #        {
        #            providerClass = listEnum.current();
        #            if (providerClass.isDimensionDatasource(_qbds))
        #            {
        #                return true;
        #            }
        #        }
        #    }
        #    return false;
        #}
      ENDSOURCE
      SOURCE #isNullValue
        #static boolean isNullValue(anytype type)
        #{
        #    return typeOf(type) == typeOf(null);
        #}
      ENDSOURCE
      SOURCE #isPackedOk
        #/*MAN
        #Method to test a packed queryrun container is legal.
        #*/
        #public static boolean isPackedOk(PackedQueryRun packed)
        #{
        #    boolean     ret;
        #
        #    ret = packed && conLen(packed) > 0;
        #
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #literalFilterValue
        #/// <summary>
        #/// Tranforms a non-literal filter value with special values into a string with all
        #/// special characters escaped.
        #/// </summary>
        #/// <param name="nonLiteralFilterValue">
        #/// The non-literal filter value which needs to have special characters--such as operators--escaped.
        #/// </param>
        #/// <returns>
        #/// The literal filter value with all special characters escaped.
        #/// </returns>
        #/// <remarks>
        #/// Use this method to prevent user entered data from being treated as an operator when the
        #/// user's data is applied as a filter.
        #/// </remarks>
        #public static str literalFilterValue(str nonLiteralFilterValue)
        #{
        #    str literalFilterValue;
        #    str specialQueryChars = ' *",.()<>!=';
        #    int pos;
        #    int i = 1;
        #    int len = strLen(nonLiteralFilterValue);
        #
        #    // Look for special characters in the string.
        #    pos = strFind(nonLiteralFilterValue, specialQueryChars, i, len - i + 1);
        #
        #    if (pos > 0)
        #    {
        #        // There exist special characters which need to be escaped.
        #        while (pos)
        #        {
        #            // Escape the special character.
        #            literalFilterValue += subStr(nonLiteralFilterValue, i, pos - i) + '\\' + subStr(nonLiteralFilterValue, pos, 1);
        #
        #            i = pos + 1;
        #            if (i <= len)
        #            {
        #                // Found another occurence of a special character.
        #                pos = strFind(nonLiteralFilterValue, specialQueryChars, i, len - i + 1);
        #            }
        #            else
        #            {
        #                // No more special characters found.
        #                pos = 0;
        #            }
        #        }
        #
        #        if (i <= len)
        #        {
        #            // Append any characters remaining on the string.
        #            literalFilterValue += subStr(nonLiteralFilterValue, i, len - i + 1);
        #        }
        #    }
        #    else
        #    {
        #        // There are no special characters that need to be escaped.
        #        literalFilterValue = nonLiteralFilterValue;
        #    }
        #
        #    return literalFilterValue;
        #}
      ENDSOURCE
      SOURCE #mergeFilters
        #/// <summary>
        #/// Merges the filters from the source query to the target query.
        #/// </summary>
        #/// <param name="_sourceQuery">
        #/// The source query.
        #/// </param>
        #/// <param name="_targetQuery">
        #/// The target query.
        #/// </param>
        #/// <param name="_sourceQueryDataSourceIndex">
        #/// The index of the datasource in the source query; optional.
        #/// </param>
        #/// <param name="_alwaysAddDatasource">
        #/// A boolean value that indicates whether to always add the datasource to the target query; optional.
        #/// </param>
        #/// <param name="_doNotAddQueryFilterForSameField">
        #/// A boolean value that indicates whether adding a query filter for the same field to the target query should not be done; optional.
        #/// </param>
        #/// <exception cref="Exception::Error">
        #/// The source query is null.
        #/// </exception>
        #/// <exception cref="Exception::Error">
        #/// The source datasource is null.
        #/// </exception>
        #/// <exception cref="Exception::Error">
        #/// The target query is null.
        #/// </exception>
        #/// <exception cref="Exception::Error">
        #/// The source datasource was not found on the target query and adding the datasource is not allowed.
        #/// </exception>
        #public static void mergeFilters(
        #    Query       _sourceQuery,
        #    Query       _targetQuery,
        #    int         _sourceQueryDataSourceIndex = 1,
        #    boolean     _alwaysAddDatasource = false,
        #    boolean     _doNotAddQueryFilterForSameField = false)
        #{
        #    QueryFilter sourceQueryFilter;
        #    QueryFilter targetQueryFilter;
        #    QueryBuildDataSource sourceDataSource;
        #    int         filterIndex;
        #    int         targetQueryDataSourceIndex = _sourceQueryDataSourceIndex;
        #    DictField   dictField;
        #
        #    if (_sourceQuery == null)
        #    {
        #        throw error(strFmt("@SYS23669", funcName()));
        #    }
        #
        #    sourceDataSource = _sourceQuery.dataSourceNo(_sourceQueryDataSourceIndex);
        #
        #    if (sourceDataSource == null)
        #    {
        #        throw error(strFmt("@SYS23667", funcName()));
        #    }
        #
        #    if (_targetQuery == null)
        #    {
        #        throw error(strFmt("@SYS23669", funcName()));
        #    }
        #
        #    if (_targetQuery.dataSourceCount() >= _sourceQueryDataSourceIndex)
        #    {
        #        if (_targetQuery.dataSourceNo(targetQueryDataSourceIndex).file() != sourceDataSource.file())
        #        {
        #            if (_alwaysAddDatasource)
        #            {
        #                _targetQuery.addDataSource(sourceDataSource.file());
        #                targetQueryDataSourceIndex = _targetQuery.dataSourceCount();
        #            }
        #            else
        #            {
        #               throw error(strFmt("@SYS23668", funcName()));
        #            }
        #        }
        #    }
        #    else
        #    {
        #        _targetQuery.addDataSource(sourceDataSource.file());
        #        targetQueryDataSourceIndex = _targetQuery.dataSourceCount();
        #    }
        #
        #    for (filterIndex = 1; filterIndex <= _sourceQuery.queryFilterCount(); filterIndex++)
        #    {
        #        sourceQueryFilter = _sourceQuery.queryFilter(filterIndex);
        #        Debug::assert(sourceQueryFilter != null);
        #
        #        if (sourceQueryFilter.dataSource().table() == sourceDataSource.table())
        #        {
        #            dictField = new DictField(sourceQueryFilter.dataSource().table(), fieldName2id(sourceDataSource.table(), sourceQueryFilter.field()));
        #            if (dictField == null)
        #            {
        #                // skip an invalid field
        #                continue;
        #            }
        #
        #            targetQueryFilter = SysQuery::findTargetQueryFilter(
        #                _sourceQuery,
        #                _targetQuery,
        #                sourceQueryFilter,
        #                targetQueryDataSourceIndex,
        #                dictField.name(),
        #                dictField.arrayIndex(),
        #                _doNotAddQueryFilterForSameField);
        #
        #            if (targetQueryFilter != null)
        #            {
        #                if (sourceQueryFilter.value() != '')
        #                {
        #                    targetQueryFilter.value(sourceQueryFilter.value());
        #                }
        #
        #                switch (sourceQueryFilter.status())
        #                {
        #                    case RangeStatus::Locked:
        #                        if (targetQueryFilter.status() == RangeStatus::Open)
        #                        {
        #                            // Locked is more restricted than Open
        #                            targetQueryFilter.status(RangeStatus::Locked);
        #                        }
        #                        break;
        #                    case RangeStatus::Hidden:
        #                        if (targetQueryFilter.status() == RangeStatus::Open || targetQueryFilter.status() == RangeStatus::Locked)
        #                        {
        #                            // Hidden is more restricted than Open and Locked
        #                            targetQueryFilter.status(RangeStatus::Hidden);
        #                        }
        #                        break;
        #                }
        #            }
        #        }
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #mergeRanges
        #public static void mergeRanges(Query       q,
        #                               Query       initQ,
        #                               int         initQdsNo = 1,
        #                               boolean     alwaysAddDatasource     = false,
        #                               boolean     addSameFieldRange       = true)
        #{
        #    QueryBuildRange     fromQbr;
        #    QueryBuildRange     toQbr;
        #    QueryBuildDynalink  dyna;
        #    Counter             fromI = 1;
        #    int                 qdsNo = initQdsNo;
        #    Counter             toI;
        #    TableId             tableId;
        #    DictField           dictField;
        #
        #    void add()
        #    {
        #        q.addDataSource(initQ.dataSourceNo(initQdsNo).file());
        #        qdsNo = q.dataSourceCount();
        #    }
        #
        #    boolean findToQbr(FieldName _fieldName, ArrayIdx _arrayIndex = 1)
        #    {
        #        FieldId fieldId;
        #        toQbr       = null;
        #
        #        // get table id & field id
        #        tableId = q.dataSourceNo(qdsNo).table();
        #        fieldId = fieldName2id(tableId, _fieldName);
        #
        #        dictField = new DictField(tableId, fieldId);
        #
        #        // If this is a dimension field, get range using the array index, otherwise get range with id
        #        if ( (dictField.arraySize() > 1 && q.dataSourceNo(qdsNo).findRange(fieldId, 1, _arrayIndex)) ||
        #             (dictField.arraySize() <= 1 && q.dataSourceNo(qdsNo).findRange(fieldId)) )
        #        {
        #            // If same range is found, then next range
        #            if (! addSameFieldRange)
        #            {
        #                return false;
        #            }
        #
        #            toI = 1;
        #            while (toI)
        #            {
        #                // is this a Dimension field?
        #                if (dictField.arraySize() > 1)
        #                    toQbr  = q.dataSourceNo(qdsNo).findRange(fieldId, toI, _arrayIndex);
        #                else
        #                    toQbr  = q.dataSourceNo(qdsNo).findRange(fieldId,toI);
        #
        #                if (! toQbr)
        #                    break;
        #
        #                // If To value is empty, use it later
        #                if (! toQbr.value())
        #                    break;
        #
        #                // If To and From values are equal then add new range later
        #                if (toQbr.value() == fromQbr.value())
        #                    break;
        #
        #                toI++;
        #            }
        #        }
        #        if (! toQbr             ||
        #            (addSameFieldRange  &&
        #             toQbr              &&
        #             toQbr.value()      &&
        #             fromQbr.value()    &&
        #             toQbr.value()      != fromQbr.value()
        #            )
        #           )
        #        {
        #
        #            if (dictField.arraySize() > 1)
        #            {
        #                // yes, working with Dimension
        #                toQbr  = q.dataSourceNo(qdsNo).addRange(fieldId, _arrayIndex);
        #            }
        #            else
        #            {
        #                toQbr  = q.dataSourceNo(qdsNo).addRange(fieldId);
        #            }
        #        }
        #
        #        return true;
        #    }
        #
        #    // Start
        #
        #    if (! initQ)
        #        throw error(strFmt("@SYS23669",funcName()));
        #
        #    if (! initQ.dataSourceNo(initQdsNo))
        #        throw error(strFmt("@SYS23667",funcName()));
        #
        #    if (! q)
        #        throw error(strFmt("@SYS23669",funcName()));
        #
        #    if (q.dataSourceCount() >= initQdsNo)
        #    {
        #        if (q.dataSourceNo(initQdsNo).file() != initQ.dataSourceNo(initQdsNo).file())
        #        {
        #            if (alwaysAddDatasource)
        #                add();
        #            else
        #               throw error(strFmt("@SYS23668",funcName()));
        #        }
        #    }
        #    else
        #        add();
        #
        #    if (! initQ)
        #        return;
        #
        #    for (fromI=1;fromI<=initQ.dataSourceNo(initQdsNo).rangeCount();fromI++)
        #    {
        #        fromQbr = initQ.dataSourceNo(initQdsNo).range(fromI);
        #
        #        dictField = new DictField(fromQbr.dataSource().table(), fromQbr.field());
        #
        #        if (!findToQbr(dictField.name(), dictField.arrayIndex()))
        #        {
        #            continue;
        #        }
        #
        #        if (toQbr)
        #        {
        #            // Only set if From has a value
        #            if (fromQbr.value())
        #                toQbr.value(fromQbr.value());
        #
        #            switch (fromQbr.status())
        #            {
        #                case RangeStatus::Locked:
        #                    if (toQbr.status() == RangeStatus::Open)
        #                        toQbr.status(RangeStatus::Locked);
        #                    break;
        #                case RangeStatus::Hidden:
        #                    switch (toQbr.status())
        #                    {
        #                        case RangeStatus::Open,RangeStatus::Locked:
        #                            toQbr.status(RangeStatus::Hidden);
        #                            break;
        #                    }
        #                    break;
        #            }
        #        }
        #
        #    }
        #
        #    fromI = 1;
        #    while (fromI <= initQ.dataSourceNo(initQdsNo).dynalinkCount())
        #    {
        #        dyna =  initQ.dataSourceNo(initQdsNo).dynalink(fromI);
        #        dictField = new DictField(dyna.dataSource().table(), dyna.field());
        #
        #        if (!findToQbr(dictField.name(), dictField.arrayIndex()))
        #        {
        #            continue;
        #        }
        #
        #        if (toQbr)
        #            toQbr.value(queryValue(dyna.cursor().(dyna.dynamicField())));
        #
        #        fromI++;
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #packDataSource
        #private static client server container packDataSource(int _packVersion, Query _query, int _dataSourceUniqueId, int _queryNextUniqueId, int dataSourceNo)
        #{
        #    QueryBuildDataSource    queryBuildDataSource = _query.dataSourceUniqueId(_dataSourceUniqueId);
        #    QueryBuildRange         queryBuildRange;
        #    QueryBuildDataSource    childDataSource;
        #    QueryBuildLink          queryBuildLink;
        #    DictIndex               dictIndex;
        #    QueryBuildDataSource    groupByDataSource;
        #    QueryBuildDataSource    orderByDataSource;
        #    QueryGroupByField       groupByField;
        #    QueryOrderByField       orderByField;
        #    container               dataSourcePack;
        #    container               rangePack;
        #    container               sortingPack;
        #    container               indexPack;
        #    container               relatedTablesPack;
        #    container               linkPack;
        #    container               groupByPack;
        #    container               orderByPack;
        #    container               aggregatePack;
        #    container               havingPack;
        #    boolean                 linkAuto;
        #    int                     position;
        #    int                     i;
        #    int                     elements;
        #    FieldName               fieldName;
        #    TableName               tableName;
        #    RangeStatus             rangeStatus;
        #    DictField               dictField;
        #    DictField               dictFieldByName;
        #    str                     rangeValue;
        #    Types                   rangeType;
        #    DictTable               parentTable, detailTable;
        #    DictField               parentField, detailField;
        #    DimensionComponent      dimensionComponent;
        #    Name                    dimensionAttributeName;
        #
        #    if (queryBuildDataSource.enabled())
        #    {
        #        // Pack table name
        #        dataSourcePack = conIns(dataSourcePack, #packTableIdPos, [tableId2name(queryBuildDataSource.table())]);
        #
        #        // Pack links
        #        if (_dataSourceUniqueId >= _queryNextUniqueId)
        #        {
        #            if (queryBuildDataSource.relations())
        #            {
        #                linkAuto = true;
        #            }
        #            else
        #            {
        #                position = 0;
        #                elements = queryBuildDataSource.linkCount();
        #                for (i=1; i<=elements; i++)
        #                {
        #                    queryBuildLink =  queryBuildDataSource.link(i);
        #
        #                    // Support SCsc
        #                    parentTable = new DictTable(queryBuildLink.table());
        #                    parentField = SysDictField::findFieldById(queryBuildLink.table(), queryBuildLink.field());
        #                    detailTable = new DictTable(queryBuildLink.relatedTable());
        #                    detailField = SysDictField::findFieldById(queryBuildLink.relatedTable(), queryBuildLink.relatedField());
        #
        #                    position++;
        #                    linkPack    = conIns(linkPack, position, [parentField.name(), detailField.name()]);
        #                }
        #            }
        #        }
        #        dataSourcePack = conIns(dataSourcePack, #packLinkPos, [linkAuto, linkPack]);
        #
        #        position = 0;
        #
        #        // Pack ranges
        #        elements = queryBuildDataSource.rangeCount();
        #        for (i=1; i <= elements; i++)
        #        {
        #            queryBuildRange = queryBuildDataSource.range(i);
        #            position++;
        #
        #            tableName=tableId2name(queryBuildRange.tableSelector()? queryBuildRange.tableSelector(): queryBuildDataSource.table());
        #            dictField = new DictField(queryBuildRange.tableSelector()? queryBuildRange.tableSelector(): queryBuildDataSource.table(), queryBuildRange.field());
        #
        #            if(dictField)
        #            {
        #                fieldName = dictField.name();
        #                rangeType = dictField.baseType();
        #            }
        #            else
        #            {
        #                // If tableSelector is not set above, this could lead to potentially wrong result for dictField (ie: derived field)
        #                // Therefore, we need to to find fieldName by going down chain
        #                // In the case of derived fields, we need to pack with the right fieldName and tableName
        #                dictFieldByName = SysDictField::findFieldByName(tableId2name(queryBuildRange.dataSource().table()), queryBuildRange.fieldName());
        #                if(dictFieldByName)
        #                {
        #                    fieldName = dictFieldByName.name();
        #                    tableName = tableId2name(dictFieldByName.tableid());
        #                    rangeType = dictFieldByName.baseType();
        #                }
        #
        #            }
        #
        #            rangeStatus = queryBuildRange.status();
        #            rangeValue = queryBuildRange.value();
        #            if (_packVersion >= #packEnumByValues && rangeType == Types::Enum)
        #            {
        #                rangeValue = DictEnum::queryRangeNames2Values(queryBuildRange);
        #            }
        #            rangePack       = conIns(rangePack, position, [fieldName,
        #                                                            queryBuildRange.label(),
        #                                                            rangeValue,
        #                                                            rangeStatus,
        #                                                            queryBuildRange.doesRangeNodeBelongToCompositeQuery(),
        #                                                            tableName
        #                                                            ]);
        #
        #        }
        #        dataSourcePack = conIns(dataSourcePack, #packRangePos, rangePack);
        #
        #        // Sorting
        #        // Pack only the first index.
        #        position = 0;
        #        elements = queryBuildDataSource.sortIndexCount();
        #        for (i=1; i <= elements; i++)
        #        {
        #            dictIndex   = new DictIndex(queryBuildDataSource.table(), queryBuildDataSource.sortIndex(i));
        #            if(dictIndex)
        #            {
        #                position++;
        #                indexPack = conIns(indexPack, position,indexId2name(queryBuildDataSource.table(),dictIndex.id()));
        #                break;
        #            }
        #        }
        #
        #        dataSourcePack = conIns(dataSourcePack, #packSortingPos, [indexPack, sortingPack]);
        #
        #        // Tables added in the query dialog
        #        position = 0;
        #        elements = queryBuildDataSource.childDataSourceCount();
        #        for (i=1; i <= elements; i++)
        #        {
        #            childDataSource = queryBuildDataSource.childDataSourceNo(i);
        #            if (childDataSource.uniqueId() >= _queryNextUniqueId &&
        #                childDataSource.enabled() &&
        #                !SysQuery::isDimensionDataSource(childDataSource))
        #            {
        #                position++;
        #                relatedTablesPack = conIns(relatedTablesPack, position, SysQuery::packDataSource(_packVersion, _query, childDataSource.uniqueId(), _queryNextUniqueId, dataSourceNo + i));
        #            }
        #        }
        #        dataSourcePack = conIns(dataSourcePack, #packRelatedTablesPos, relatedTablesPack);
        #
        #        if (dataSourceNo == 1)
        #        {
        #            // Clear any order by fields
        #            // that mirror sort indexes.
        #            SysQuery::packHandleSortIndex(_query);
        #
        #            // Pack group by fields
        #            elements = _query.groupByFieldCount();
        #            position = 0;
        #            for (i=1; i <= elements; i++)
        #            {
        #                groupByField = _query.groupByField(i);
        #                groupByDataSource = groupByField.dataSource();
        #                if (groupByDataSource.enabled())
        #                {
        #                    position++;
        #                    dictField = SysDictField::findFieldById((groupByField.tableSelector()? groupByField.tableSelector(): groupByDataSource.table()), groupByField.fieldID());
        #                    if(dictField)
        #                    {
        #                        fieldName = dictField.name();
        #                        tableName=tableId2name(groupByField.tableSelector()? groupByField.tableSelector(): groupByDataSource.table());
        #                        groupByPack = conIns(groupByPack, position,
        #                                            [groupByDataSource.uniqueId(),
        #                                            fieldName,
        #                                            groupByField.autoHeader(),
        #                                            groupByField.autoHeaderDetailLevel(),
        #                                            groupByField.autoSum(),
        #                                            groupByField.autoSumDetailLevel(),
        #                                            tableName]);
        #                    }
        #                }
        #            }
        #            dataSourcePack = conIns(dataSourcePack, #packGroupByPos, groupByPack);
        #
        #            // Pack order by fields
        #            elements = _query.orderByFieldCount();
        #            position = 0;
        #            for (i=1; i <= elements; i++)
        #            {
        #                orderByField = _query.orderByField(i);
        #                orderByDataSource = orderByField.dataSource();
        #                if (orderByDataSource.enabled())
        #                {
        #                    position++;
        #                    dictField = SysDictField::findFieldById((orderByField.tableSelector()? orderByField.tableSelector(): orderByDataSource.table()), orderByField.fieldID());
        #                    if(dictField)
        #                    {
        #                        if (SysQuery::isDimensionDataSource(orderByDataSource))
        #                        {
        #                            tableName = tableId2name(orderByDataSource.parentDataSource().table());
        #                            [dimensionComponent, dimensionAttributeName, fieldName] = SysQuery::getDimComponentAttAndFieldFromOrderBy(orderByField);
        #
        #                            orderByPack = conIns(orderByPack, position,
        #                                                [orderByDataSource.parentDataSource().uniqueId(),
        #                                                fieldName,
        #                                                orderByField.direction(),
        #                                                orderByField.autoHeader(),
        #                                                orderByField.autoHeaderDetailLevel(),
        #                                                orderByField.autoSum(),
        #                                                orderByField.autoSumDetailLevel(),
        #                                                tableName,
        #                                                true,
        #                                                dimensionComponent,
        #                                                dimensionAttributeName]);
        #                        }
        #                        else
        #                        {
        #                            fieldName = dictField.name();
        #                            tableName=tableId2name(orderByField.tableSelector()? orderByField.tableSelector(): orderByDataSource.table());
        #
        #                            orderByPack = conIns(orderByPack, position,
        #                                                [orderByDataSource.uniqueId(),
        #                                                fieldName,
        #                                                orderByField.direction(),
        #                                                orderByField.autoHeader(),
        #                                                orderByField.autoHeaderDetailLevel(),
        #                                                orderByField.autoSum(),
        #                                                orderByField.autoSumDetailLevel(),
        #                                                tableName,
        #                                                false,
        #                                                DimensionComponent::AccountStructure,
        #                                                '']);
        #                        }
        #                    }
        #                }
        #            }
        #            dataSourcePack = conIns(dataSourcePack, #packOrderByPos, orderByPack);
        #
        #            // pack aggregate and having fields
        #            if (_packVersion >= #packExtendedDataSourceForDimensionVersion)
        #            {
        #                aggregatePack = SysQuery::packDataSourceAggregates(_query);
        #                dataSourcePack = conIns(dataSourcePack, #packAggregatePos, aggregatePack);
        #
        #                havingPack = SysQuery::packDataSourceHaving(_query);
        #                dataSourcePack = conIns(dataSourcePack, #packHavingPos, havingPack);
        #            }
        #        }
        #
        #        if (_packVersion >= #packExtendedDataSourceForDimensionVersion)
        #        {
        #            // insert empty container of groupby and orderby in sub sequent datasources
        #            // so that positions of later content are maintained correctly
        #            if (dataSourceNo != 1)
        #            {
        #                dataSourcePack = conIns(dataSourcePack, #packGroupByPos, conNull());
        #                dataSourcePack = conIns(dataSourcePack, #packOrderByPos, conNull());
        #            }
        #            // pack datasource unique id
        #            dataSourcePack = conIns(dataSourcePack, #packDataSourceUniqueIdPos, _dataSourceUniqueId);
        #
        #            // pack datasource name
        #            dataSourcePack = conIns(dataSourcePack, #packDataSourceNamePos, queryBuildDataSource.name());
        #
        #            // pack datasource join mode
        #            dataSourcePack = conIns(dataSourcePack, #packDataSourceJoinModePos, queryBuildDataSource.joinMode());
        #
        #            // pack datasource fetch mode
        #            dataSourcePack = conIns(dataSourcePack, #packDataSourceFetchModePos, queryBuildDataSource.fetchMode());
        #        }
        #
        #    }
        #    return dataSourcePack;
        #}
      ENDSOURCE
      SOURCE #packDataSourceAggregates
        #/// <summary>
        #/// This method packs the aggregate information from the data source into a container.
        #/// </summary>
        #/// <param name="_query">
        #/// A query.
        #/// </param>
        #/// <returns>
        #/// A container with packed aggregate information.
        #/// </returns>
        #private static container packDataSourceAggregates(Query _query)
        #{
        #    container       pack;
        #    int             fieldCount, position, dataSourceUniqueId, dataSourceCount, i, j;
        #    FieldId         fldId;
        #    SelectionField  selType;
        #    QueryBuildDataSource dataSource;
        #
        #    pack = conNull();
        #
        #    dataSourceCount = _query.dataSourceCount();
        #
        #    for (i=1; i<=dataSourceCount; i++)
        #    {
        #        dataSource = _query.dataSourceNo(i);
        #        dataSourceUniqueId = dataSource.uniqueId();
        #
        #        fieldCount = dataSource.fields().fieldCount();
        #        position = 0;
        #        for (j=1; j <= fieldCount; j++)
        #        {
        #            selType = dataSource.fields().fieldKind(j);
        #            if (selType != SelectionField::Database && selType != SelectionField::ComputedColumn)
        #            {
        #                position++;
        #                fldId = dataSource.fields().field(j);
        #                pack = conIns(pack, position, [fldId, selType, dataSourceUniqueId]);
        #            }
        #        }
        #    }
        #
        #    return pack;
        #}
      ENDSOURCE
      SOURCE #packDataSourceHaving
        #/// <summary>
        #/// This method packs the having clause information from the data source into a container.
        #/// </summary>
        #/// <param name="_query">
        #/// A query.
        #/// </param>
        #/// <returns>
        #/// A container with packed having clause information.
        #/// </returns>
        #private static container packDataSourceHaving(Query _query)
        #{
        #    container               pack;
        #    Counter                 havingFilterCount, filterCounter;
        #    QueryHavingFilter       queryHavingFilter;
        #
        #    pack = conNull();
        #
        #    havingFilterCount = _query.havingFilterCount();
        #
        #    for (filterCounter=1; filterCounter <= havingFilterCount; filterCounter++)
        #    {
        #        queryHavingFilter = _query.havingFilter(filterCounter);
        #        pack = conIns(pack, filterCounter, [queryHavingFilter.dataSource().uniqueId(), queryHavingFilter.fieldName(), queryHavingFilter.aggregateFunction(), queryHavingFilter.value()]);
        #    }
        #
        #
        #    return pack;
        #}
      ENDSOURCE
      SOURCE #packDimensionRanges
        #/// <summary>
        #/// Packs dimension ranges from the query.
        #/// </summary>
        #/// <param name="_packVersion">
        #/// Current pack version for the class.
        #/// </param>
        #/// <param name="_query">
        #/// The query to which to add dimension ranges.
        #/// </param>
        #/// <returns>
        #/// The container that contains the dimension ranges.
        #/// </returns>
        #public static client server container packDimensionRanges(int _packVersion, Query _query)
        #{
        #    List                    dimensionRangeList;
        #    ListEnumerator          listEnum;
        #    container               rangePack = conNull();
        #
        #    if (_packVersion >= #packDimensionRangesVersion)
        #    {
        #        // Pack dimension ranges
        #        dimensionRangeList = SysQuery::getDimensionRangesFromQuery(_query);
        #        listEnum = dimensionRangeList.getEnumerator();
        #        while (listEnum.moveNext())
        #        {
        #            rangePack += [listEnum.current()];
        #        }
        #    }
        #
        #    return rangePack;
        #}
      ENDSOURCE
      SOURCE #packHandleSortIndex
        #private static void packHandleSortIndex(Query q)
        #{
        #    QueryBuildDataSource currentDataSource;
        #    QueryBuildDataSource targetDataSource;
        #    QueryBuildDataSource currentRoot;
        #    List rootList = new List(Types::Integer);
        #    List groupList;
        #    ListEnumerator rootListEnumerator;
        #    ListEnumerator groupListEnumerator;
        #
        #    Map groupMap = new Map(Types::Integer, Types::Class);
        #
        #    DictTable dictTable;
        #    DictIndex dictIndex;
        #    QueryOrderByField orderByField;
        #
        #    int i;
        #    int rootKey;
        #    int elements;
        #    int orderByFieldIndex;
        #    int orderByFieldCount = q.orderByFieldCount();
        #
        #    boolean isEligible;
        #    boolean foundSortIndex;
        #    ;
        #
        #    // Determine the group of data sources
        #    // that will be executed as a unit.
        #    elements = q.dataSourceCount();
        #    for (i=1; i <= elements; i++)
        #    {
        #        currentDataSource = q.dataSourceNo(i);
        #
        #        // Get top most parent data source.
        #        currentRoot = currentDataSource;
        #        while (currentRoot.joined())
        #        {
        #            dictTable = new DictTable(currentRoot.table());
        #            if (dictTable && dictTable.isTmp())
        #            {
        #                break;
        #            }
        #
        #            dictTable = new DictTable(currentRoot.parentDataSource().table());
        #            if (dictTable && dictTable.isTmp())
        #            {
        #                break;
        #            }
        #            currentRoot = currentRoot.parentDataSource();
        #        }
        #
        #        if (groupMap.exists(currentRoot.uniqueId()))
        #        {
        #            groupList = groupMap.lookup(currentRoot.uniqueId());
        #        }
        #        else
        #        {
        #            rootList.addEnd(currentRoot.uniqueId());
        #            groupList = new List(Types::Class);
        #            groupMap.insert(currentRoot.uniqueId(), groupList);
        #
        #        }
        #        groupList.addEnd(currentDataSource);
        #    }
        #
        #
        #    // Enumerate through each data source group.
        #    // The root list contains the key into the groupMap.
        #    rootListEnumerator = rootList.getEnumerator();
        #    while (rootListEnumerator.moveNext())
        #    {
        #        rootKey = rootListEnumerator.current();
        #        if (groupMap.exists(rootKey))
        #        {
        #            groupList = groupMap.lookup(rootKey);
        #            groupListEnumerator = groupList.getEnumerator();
        #            foundSortIndex = false;
        #            isEligible = true;
        #
        #            // Loop through each data source in the group.
        #            while (groupListEnumerator.moveNext() && isEligible)
        #            {
        #                currentDataSource = groupListEnumerator.current();
        #
        #                // If the data source is part of the group by list
        #                // then the sort index (if any) is invalid and should be ignored.
        #                elements = q.groupByFieldCount();
        #                for (i = 1; i <= elements; i++)
        #                {
        #                    if (q.groupByField(i).dataSource().uniqueId() == currentDataSource.uniqueId())
        #                    {
        #                        isEligible = false;
        #                        break;
        #                    }
        #                }
        #
        #                dictIndex = null;
        #                if (currentDataSource.sortIndexCount())
        #                {
        #                    // Find the first valid index.
        #                    elements = currentDataSource.sortIndexCount();
        #                    for (i=1; i <= elements; i++)
        #                    {
        #                        dictIndex = new DictIndex(currentDataSource.table(), currentDataSource.sortIndex(i));
        #                        if (dictIndex)
        #                        {
        #                            break;
        #                        }
        #                    }
        #                }
        #
        #                if (dictIndex)
        #                {
        #                    if (!foundSortIndex)
        #                    {
        #                        // Set the orderByFieldIndex to the first order by field
        #                        // that matches the current data source.
        #                        foundSortIndex = true;
        #                        for (orderByFieldIndex = 1; orderByFieldIndex <= orderByFieldCount; orderByFieldIndex++)
        #                        {
        #                            orderByField = q.orderByField(i);
        #                            targetDataSource = orderByField.dataSource();
        #                            if (targetDataSource.uniqueId() == currentDataSource.uniqueId())
        #                            {
        #                                break;
        #                            }
        #                        }
        #                    }
        #
        #                    elements = dictIndex.numberOfFields();
        #                    if (elements  != currentDataSource.sortFieldCount())
        #                    {
        #                        isEligible = false;
        #                        break;
        #                    }
        #
        #                    for (i = 1; i <= elements; i++)
        #                    {
        #                        if (orderByFieldIndex <= orderByFieldCount)
        #                        {
        #                            targetDataSource = q.orderByField(orderByFieldIndex).dataSource();
        #
        #                            orderByFieldIndex++; // set index to next field in order by list.
        #
        #                            if (targetDataSource.sortField(i)       != dictIndex.field(i)||
        #                                targetDataSource.sortDirection(i)   != SortOrder::Ascending ||
        #                                targetDataSource.autoHeader(i) ||
        #                                targetDataSource.autoSum(i) ||
        #                                targetDataSource.autoHeaderDetailLevel(i) ||
        #                                targetDataSource.autoSumDetailLevel(i))
        #                            {
        #                                isEligible = false;
        #                                break;
        #                            }
        #                        }
        #                        else
        #                        {
        #                            // Could not match all sort index fields,
        #                            // so we should fail at this point.
        #                            isEligible = false;
        #                            break;
        #                        }
        #                    }
        #                }
        #                else
        #                {
        #                    for (i = 1; i <= orderByFieldCount; i++)
        #                    {
        #                        orderByField = q.orderByField(i);
        #                        targetDataSource = orderByField.dataSource();
        #                        if (targetDataSource.uniqueId() == currentDataSource.uniqueId())
        #                        {
        #                            isEligible = false;
        #                        }
        #                        break;
        #                    }
        #                }
        #            }
        #
        #            // We have processed all data source for
        #            // the group.  If we found sort indexes
        #            // and they align with the order by fields,
        #            // then we will clear them for the data source group.
        #            if (foundSortIndex && isEligible)
        #            {
        #                groupListEnumerator.reset();
        #                while (groupListEnumerator.moveNext())
        #                {
        #                    currentDataSource = groupListEnumerator.current();
        #                    currentDataSource.orderMode(OrderMode::OrderBy);
        #                    currentDataSource.sortClear();
        #                }
        #
        #            }
        #        }
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #packQueryFilters
        #/// <summary>
        #/// Packs the query filters
        #/// </summary>
        #/// <param name="_packVersion">
        #/// Current pack version for the <c>QueryFilter</c> class.
        #/// </param>
        #/// <param name="_query">
        #/// The query to which to add query filters.
        #/// </param>
        #/// <returns>
        #/// The container that contains the query filters.
        #/// </returns>
        #public static client server container packQueryFilters(int _packVersion, Query _query)
        #{
        #    int                     queryFilterCnt;
        #    QueryFilter             queryFilter;
        #    int                     queryFilterPos = 0;
        #    container               filterPack;
        #    int                     i;
        #    FieldName               fieldName;
        #    TableName               tableName;
        #    str                     label;
        #    QueryBuildDataSource    queryBuildDataSource;
        #    SysDictField            sysDictField;
        #    str                     filterValue;
        #
        #    if (_packVersion >= #packQueryFilterVersion)
        #    {
        #        // Pack Filters
        #        queryFilterCnt = _query.queryFilterCount();
        #        for (i=1; i <= queryFilterCnt; i++)
        #        {
        #            queryFilter = _query.queryFilter(i);
        #            queryBuildDataSource = queryFilter.dataSource();
        #
        #            queryFilterPos++;
        #            fieldName = queryFilter.field();
        #            tableName = tableId2name(queryBuildDataSource.table());
        #            label = "";
        #
        #            filterValue = queryFilter.value();
        #            if (_packVersion >= #packEnumByValues)
        #            {
        #                sysDictField = SysDictField::findFieldByName(tableId2name(queryBuildDataSource.table()),queryFilter.field());
        #                if (sysDictField
        #                    && sysDictField.baseType() == Types::Enum)
        #                {
        #                    filterValue = DictEnum::queryFilterNames2Values(queryFilter);
        #                }
        #            }
        #
        #            filterPack = conIns(filterPack, queryFilterPos, [fieldName,
        #                                                                label ,                     // label BUG 86133
        #                                                                filterValue ,               // value
        #                                                                queryFilter.status(),       // status
        #                                                                false               ,       // doesRangeNodeBelongToCompositeQuery -> NEED TO API's SUPPORT
        #                                                                tableName           ,       //
        #                                                                queryBuildDataSource.uniqueId() // dataSourceUniqueId
        #
        #                                                                ]);
        #        }
        #    }
        #
        #    return filterPack;
        #}
      ENDSOURCE
      SOURCE #packRangeAndSortorder
        #public static client server container packRangeAndSortorder(Query _query, int _queryNextUniqueId = 0)
        #{
        #    QueryBuildDataSource queryBuildDataSource;
        #    container            queryPack;
        #    container            dimensionRangesPack;
        #    container            companyRangesPack;
        #    container            validTimeRangesPack;
        #    container            internalsPack;
        #    int                  queryNextUniqueId = _queryNextUniqueId;
        #    int                  dataSourceCnt;
        #    int                  i, j;
        #    container            filterPack;
        #
        #    if (_query)
        #    {
        #
        #        if (!queryNextUniqueId)
        #        {
        #            queryNextUniqueId = _query.getNextUniqueId();
        #        }
        #
        #        // pack Filters
        #        filterPack = SysQuery::packQueryFilters(#packCurrentVersion, _query);
        #
        #        // Pack Dimension Ranges
        #        dimensionRangesPack = SysQuery::packDimensionRanges(#packCurrentVersion, _query);
        #
        #        // Pack Ranges
        #        dataSourceCnt = _query.dataSourceCount();
        #        for (i=1; i <= dataSourceCnt; i++)
        #        {
        #            queryBuildDataSource = _query.dataSourceNo(i);
        #            if (queryBuildDataSource.uniqueId() < queryNextUniqueId &&
        #                queryBuildDataSource.enabled())
        #            {
        #                j++;
        #                queryPack = conIns(queryPack, j, SysQuery::packDataSource(#packCurrentVersion, _query, queryBuildDataSource.uniqueId(), queryNextUniqueId, i));
        #            }
        #        }
        #
        #        if (_query.allowCrossCompany())
        #        {
        #            companyRangesPack = _query.getCompanyRange();
        #        }
        #        else
        #        {
        #            companyRangesPack = conNull();
        #        }
        #
        #        internalsPack = _query.packInternals();
        #
        #        // Date Effective: pack valid time ranges
        #        validTimeRangesPack = SysQuery::packValidTimeRanges(_query);
        #    }
        #
        #    return [#packCurrentVersion, queryPack, companyRangesPack, internalsPack, validTimeRangesPack, filterPack, dimensionRangesPack];
        #}
      ENDSOURCE
      SOURCE #packValidTimeRanges
        #private static client server container packValidTimeRanges(Query _query)
        #{
        #    int i;
        #    QueryBuildDataSource qbds;
        #    boolean isDateTime;
        #    SysDictTable dictTable;
        #    SysDictField dictField;
        #    container validTimeRangesPack;
        #
        #;
        #    // Pack valid time query type
        #    validTimeRangesPack = conIns(validTimeRangesPack, #ValidTimeStateQueryType, [_query.getValidTimeStateQueryType()]);
        #
        #    // Pack date type
        #    for(i=1;i<=_query.dataSourceCount();i++)
        #    {
        #        qbds = _query.dataSourceNo(i);
        #        dictTable = new SysDictTable(qbds.table());
        #
        #        if ( dictTable.isValidTimeStateTable() )
        #        {
        #            dictField = new SysDictField(dictTable.id(), dictTable.getValidTimeStateValidFromFieldId());
        #            isDateTime = (dictField.baseType() == Types::UtcDateTime);
        #            break;
        #        }
        #    }
        #    validTimeRangesPack = conIns(validTimeRangesPack, #validTimeIsDatetime, [isDateTime]);
        #
        #    // Pack date ranges
        #    switch ( _query.getValidTimeStateQueryType() )
        #    {
        #    case ValidTimeStateQueryType::AsOf:
        #        if ( isDateTime )
        #        {
        #            validTimeRangesPack = conIns(validTimeRangesPack, #validTimeRanges, [_query.validTimeStateAsOfDateTime()]);
        #        }
        #        else
        #        {
        #            validTimeRangesPack = conIns(validTimeRangesPack, #validTimeRanges, [_query.validTimeStateAsOfDate()]);
        #        }
        #    break;
        #    case ValidTimeStateQueryType::Range:
        #        if ( isDateTime )
        #        {
        #            validTimeRangesPack = conIns(validTimeRangesPack, #validTimeRanges, _query.getValidTimeStateDateTimeRange());
        #        }
        #        else
        #        {
        #            validTimeRangesPack = conIns(validTimeRangesPack, #validTimeRanges, _query.getValidTimeStateDateRange());
        #        }
        #    break;
        #    }
        #    return validTimeRangesPack;
        #}
      ENDSOURCE
      SOURCE #queryAddDynaCursorAsRangeAndValue
        #// This method will traverse dynalinks on QueryBuildDataSource represented by _queryDynaBdsNo
        #// and convert current dyna-record into ranges and values on that QueryBuildDataSource
        #static client server void queryAddDynaCursorAsRangeAndValue(
        #    Query   _query,             // new query
        #    Query   _queryDyna,         // query having external links (=dyna links)
        #    Integer _queryDynaBdsNO     // queryBuildDataSource on _queryDyna having external links
        #    )
        #{
        #    QueryBuildRange     toQbr;
        #    QueryBuildDynalink  qbDyna;
        #    Counter             dynaLinkNo = 1;
        #    Counter             toI;
        #    DictField           dictField;
        #    Integer             dictIndex;
        #    Integer             originalId;
        #    Integer             queryDsNO = _queryDynaBdsNO;
        #    FieldId             id;
        #    ;
        #    if (!_queryDynaBdsNO)
        #        return;
        #
        #    if (!_query || !_queryDyna)
        #        throw error(strFmt("@SYS23669",funcName()));
        #
        #    if (!_queryDyna.dataSourceNo(_queryDynaBdsNO))
        #        throw error(strFmt("@SYS23667",funcName()));
        #
        #    if (_query.dataSourceCount() < _queryDynaBdsNO || _query.dataSourceNo(_queryDynaBdsNO).file() != _queryDyna.dataSourceNo(_queryDynaBdsNO).file())
        #    {
        #        _query.addDataSource(_queryDyna.dataSourceNo(_queryDynaBdsNO).file());
        #        queryDsNO = _query.dataSourceCount();
        #    }
        #    while (dynaLinkNo <= _queryDyna.dataSourceNo(_queryDynaBdsNO).dynalinkCount())
        #    {
        #        qbDyna      = _queryDyna.dataSourceNo(_queryDynaBdsNO).dynalink(dynaLinkNo);
        #        id          = fieldExt2Id(qbDyna.field());
        #        originalId  = id;
        #        toQbr       = null;
        #
        #        if (_query.dataSourceNo(queryDsNO).findRange(id))
        #        {
        #            toI = 1;
        #            while (true)
        #            {
        #                toQbr  = _query.dataSourceNo(queryDsNO).findRange(id,toI);
        #                if (!toQbr || !toQbr.value() || toQbr.value() == queryValue(qbDyna.cursor().(qbDyna.dynamicField())))
        #                    break;
        #                toI++;
        #            }
        #        }
        #        if (!toQbr || (toQbr && toQbr.value() && queryValue(qbDyna.cursor().(qbDyna.dynamicField())) && toQbr.value() != queryValue(qbDyna.cursor().(qbDyna.dynamicField()))))
        #        {
        #            // is this a Dimension field?
        #            dictField = new DictField(_query.dataSourceNo(queryDsNO).table(),id);
        #
        #            if (dictField.arraySize() > 1)
        #            {
        #                // yes, working with Array field
        #                dictIndex = originalId >> 16;
        #                toQbr  = _query.dataSourceNo(queryDsNO).addRange(fieldId2Ext(id, dictIndex));
        #            }
        #            else
        #            {
        #                toQbr  = _query.dataSourceNo(queryDsNO).addRange(id);
        #            }
        #        }
        #        if (toQbr)
        #            toQbr.value(queryValue(qbDyna.cursor().(qbDyna.dynamicField())));
        #
        #        dynaLinkNo++;
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #queryAddDynalinksFromGroupBy
        #/// <summary>
        #///    Creates dynamic links for all the fields by which the query should be grouped.
        #/// </summary>
        #/// <param name="_query">
        #///    A reference to a query that contains a data source for which dynamic links are to be created.
        #/// </param>
        #/// <param name="_dataSourceName">
        #///    The name of a data source for which dynamic links are to be created.
        #/// </param>
        #/// <param name="_dynamicBuffer">
        #///    A reference to a buffer to which dynamic links will be created.
        #/// </param>
        #/// <exception cref="M:Exception::Error">
        #///    A data source that is specified by the <c>_dataSourceName</c> parameter and the
        #///    <c>_dynamicBuffer</c> parameters references different tables.
        #/// </exception>
        #public client static void queryAddDynalinksFromGroupBy(
        #    Query                   _query,
        #    str                     _dataSourceName,
        #    Common                  _dynamicBuffer)
        #{
        #    QueryBuildDataSource    qbds;
        #    QueryGroupByField       groupByField;
        #    int                     groupByFieldsCount;
        #    FieldId                 groupByFieldId;
        #    int                     i;
        #
        #    qbds = _query.dataSourceName(_dataSourceName);
        #    if (qbds.table() != _dynamicBuffer.TableId)
        #    {
        #        throw error(Error::wrongUseOfFunction(funcName()));
        #    }
        #
        #    //clear existing dynalinks
        #    qbds.clearDynalinks();
        #
        #    //add links for group by fields
        #    groupByFieldsCount = _query.groupByFieldCount();
        #    for (i = 1; i <= groupByFieldsCount; ++i)
        #    {
        #        groupByField = _query.groupByField(i);
        #        groupByFieldId = fieldExt2Id(groupByField.fieldID());
        #        if (   groupByFieldId != fieldNum(Common, TableId)
        #            && groupByField.dataSource().id() == qbds.id())
        #        {
        #            qbds.addDynalink(groupByFieldId, _dynamicBuffer, groupByFieldId);
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #queryAddStaticCursorAsRangeAndValue
        #// This method will traverse static record links on QueryBuildDataSource represented by _queryStatckBdsNo
        #// and convert current static record into ranges and values on that QueryBuildDataSource
        #static client server void queryAddStaticCursorAsRangeAndValue(
        #    Query   _query,             // new query
        #    Query   _queryStatic,         // query having external links (=static links)
        #    Integer _queryStaticBdsNO     // queryBuildDataSource on _queryStatic having external links
        #    )
        #{
        #    QueryBuildRange     toQbr;
        #    QueryBuildStaticlink  qbStatic;
        #    Counter             staticLinkNo = 1;
        #    Counter             toI;
        #    DictField           dictField;
        #    Integer             dictIndex;
        #    Integer             originalId;
        #    Integer             queryDsNO = _queryStaticBdsNO;
        #    FieldId             id;
        #    ;
        #    if (!_queryStaticBdsNO)
        #        return;
        #
        #    if (!_query || !_queryStatic)
        #        throw error(strFmt("@SYS23669",funcName()));
        #
        #    if (!_queryStatic.dataSourceNo(_queryStaticBdsNO))
        #        throw error(strFmt("@SYS23667",funcName()));
        #
        #    if (_query.dataSourceCount() < _queryStaticBdsNO || _query.dataSourceNo(_queryStaticBdsNO).file() != _queryStatic.dataSourceNo(_queryStaticBdsNO).file())
        #    {
        #        _query.addDataSource(_queryStatic.dataSourceNo(_queryStaticBdsNO).file());
        #        queryDsNO = _query.dataSourceCount();
        #    }
        #    while (staticLinkNo <= _queryStatic.dataSourceNo(_queryStaticBdsNO).staticlinkCount())
        #    {
        #        qbStatic      = _queryStatic.dataSourceNo(_queryStaticBdsNO).staticlink(staticLinkNo);
        #        id          = fieldExt2Id(qbStatic.field());
        #        originalId  = id;
        #        toQbr       = null;
        #
        #        if (_query.dataSourceNo(queryDsNO).findRange(id))
        #        {
        #            toI = 1;
        #            while (true)
        #            {
        #                toQbr  = _query.dataSourceNo(queryDsNO).findRange(id,toI);
        #                if (!toQbr || !toQbr.value() || toQbr.value() == queryValue(qbStatic.value()))
        #                    break;
        #                toI++;
        #            }
        #        }
        #        if (!toQbr || (toQbr && toQbr.value() && queryValue(qbStatic.value()) && toQbr.value() != queryValue(qbStatic.value())))
        #        {
        #            // is this a Dimension field?
        #            dictField = new DictField(_query.dataSourceNo(queryDsNO).table(),id);
        #
        #            if (dictField.arraySize() > 1)
        #            {
        #                // yes, working with Array field
        #                dictIndex = originalId >> 16;
        #                toQbr  = _query.dataSourceNo(queryDsNO).addRange(fieldId2Ext(id, dictIndex));
        #            }
        #            else
        #            {
        #                toQbr  = _query.dataSourceNo(queryDsNO).addRange(id);
        #            }
        #        }
        #        if (toQbr)
        #            toQbr.value(queryValue(qbStatic.value()));
        #
        #        staticLinkNo++;
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #queryAddUniqueRangeAndValue
        #static client server void queryAddUniqueRangeAndValue(
        #    Query   _query,
        #    Common  _source
        #    )
        #{
        #    Common                  callerBuffer = _source;
        #    SysDictTable            sysDictTable = new SysDictTable(callerBuffer.TableId);
        #    QueryBuildDataSource    qbd;
        #    QueryBuildRange         qbr;
        #    DictIndex               dictIndex;
        #    Integer                 indexId;
        #    Integer                 i;
        #    FieldId                 fieldId;
        #
        #    void indexAddUniqueRangesAndValues()
        #    {
        #        for (i=1;i<=dictIndex.numberOfFields();i++)
        #        {
        #            fieldId = dictIndex.field(i);
        #            qbr = qbd.findRange(fieldId);
        #            if (!qbr)
        #                qbr = qbd.addRange(fieldId);
        #            qbr.status(RangeStatus::Locked);
        #            qbr.value(queryValue(callerBuffer.(fieldId)));
        #        }
        #    }
        #    ;
        #    if (!callerBuffer.RecId)
        #        return;
        #
        #    dictIndex   = sysDictTable.firstUniqueIndex();
        #    qbd         = _query.dataSourceTable(callerBuffer.TableId);
        #
        #    if (dictIndex)
        #    {
        #        indexAddUniqueRangesAndValues();
        #    }
        #    else
        #    {
        #        indexId = sysDictTable.indexNext(0);
        #        if (indexId)
        #        {
        #            dictIndex = sysDictTable.indexObject(indexId);
        #            indexAddUniqueRangesAndValues();
        #        }
        #        fieldId = fieldNum(Common,RecId);
        #        qbr = qbd.findRange(fieldId);
        #        if (!qbr)
        #            qbr = qbd.addRange(fieldId);
        #        qbr.status(RangeStatus::Locked);
        #        qbr.value(queryValue(callerBuffer.RecId));
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #queryFromKeyData
        #static Query queryFromKeyData(
        #    TableId         tableId,
        #    KeyData         keyData     // Should be a unique list!
        #    )
        #{
        #    Query                   q;
        #    QueryBuildDataSource    qbds;
        #
        #    q    = new Query();
        #    qbds = q.addDataSource(tableId);
        #    SysQuery::addRangesFromKeyData(qbds,keyData);
        #
        #    return q;
        #}
      ENDSOURCE
      SOURCE #queryFromTableRelation
        #public static Query queryFromTableRelation(Common _parentTable, TableId _relationTableId, boolean _update = false, boolean _noRelationNoRecords = true)
        #{
        #    Query           query;
        #    DictRelation    dictRelation;
        #    Counter         c;
        #    ;
        #
        #    dictRelation = new DictRelation(_relationTableId);
        #    dictRelation.loadTableRelation(_parentTable.TableId);
        #
        #    query = new Query();
        #    query.addDataSource(_relationTableId);
        #
        #    if (_noRelationNoRecords && dictRelation.lines() == 0)
        #    {
        #        query.dataSourceTable(_relationTableId).addRange(fieldNum(Common, TableId)).value(queryValue(0));
        #    }
        #
        #    for (c=1; c <= dictRelation.lines(); c++)
        #    {
        #        switch (dictRelation.lineType(c))
        #        {
        #            case TableRelation::Field:
        #                query.dataSourceTable(_relationTableId).addRange(dictRelation.lineTableValue(c)).value(queryValue(_parentTable.(dictRelation.lineExternTableValue(c))));
        #                break;
        #
        #            case TableRelation::ExternFixed:
        #                if (_noRelationNoRecords && _parentTable.(dictRelation.lineExternTableValue(c)) != dictRelation.lineTableValue(c))
        #                {
        #                    query.dataSourceTable(_relationTableId).addRange(fieldNum(Common, TableId)).value(queryValue(0));
        #                }
        #                break;
        #
        #            case TableRelation::ThisFixed:
        #                query.dataSourceTable(_relationTableId).addRange(dictRelation.lineTableValue(c)).value(queryValue(dictRelation.lineExternTableValue(c)));
        #                break;
        #        }
        #    }
        #
        #    query.dataSourceTable(_relationTableId).update(_update);
        #
        #    return query;
        #}
      ENDSOURCE
      SOURCE #queryHasFilters
        #/// <summary>
        #/// Gets a boolean value that indicates whether the query has any filters.
        #/// </summary>
        #/// <param name="_query">
        #/// The query to search.
        #/// </param>
        #/// <returns>
        #/// A boolean value that indicates whether the query has any filters.
        #/// </returns>
        #public static boolean queryHasFilters(Query _query)
        #{
        #    int i;
        #
        #    for (i = 1; i <= _query.queryFilterCount(); i++)
        #    {
        #        if (_query.queryFilter(i).value())
        #        {
        #            return true;
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #queryHasRanges
        #/// <summary>
        #/// Gets a boolean value that indicates whether the query has any ranges.
        #/// </summary>
        #/// <param name="_query">
        #/// The query to search.
        #/// </param>
        #/// <returns>
        #/// A boolean value that indicates whether the query has any ranges.
        #/// </returns>
        #public static boolean queryHasRanges(Query _query)
        #{
        #    int i, range;
        #    QueryBuildDataSource qbds;
        #    QueryBuildRange qbr;
        #
        #    for (i = 1; i <= _query.dataSourceCount(); i++)
        #    {
        #        qbds = _query.dataSourceNo(i);
        #        if (qbds.enabled())
        #        {
        #            for (range = 1; range <= qbds.rangeCount(); range++)
        #            {
        #                qbr = qbds.range(range);
        #                if (qbr.value())
        #                {
        #                    return true;
        #                }
        #            }
        #        }
        #    }
        #
        #    return false;
        #}
      ENDSOURCE
      SOURCE #queryHasRangesOrFilters
        #/// <summary>
        #/// Gets a boolean value that indicates whether the query has any ranges or filters.
        #/// </summary>
        #/// <param name="_query">
        #/// The query to search.
        #/// </param>
        #/// <returns>
        #/// A boolean value that indicates whether the query has any ranges or filters.
        #/// </returns>
        #public static boolean queryHasRangesOrFilters(Query _query)
        #{
        #    boolean foundRangeOrFilter = false;
        #
        #    foundRangeOrFilter = SysQuery::queryHasRanges(_query) || SysQuery::queryHasFilters(_query);
        #
        #    return foundRangeOrFilter;
        #}
      ENDSOURCE
      SOURCE #range
        #//<GEERU>
        ##ISOCountryRegionCodes
        #//</GEERU>
        #/// <summary>
        #///    Retrieves a string that represents a range filter that can be used as value for a
        #///    <c>QueryBuildRange</c> object.
        #/// </summary>
        #/// <param name="_from">
        #///    The lower bound of the range; null values are enabled.
        #/// </param>
        #/// <param name="_to">
        #///    The upper bound of the range; null values are enabled.
        #/// </param>
        #/// <param name="treatOnlyNullAsUnbound">
        #///     true if only null values are treated as unbound values; false if both empty and null values are be
        #///    treated as unbound values; optional.
        #/// </param>
        #/// <returns>
        #///    A string that represents a range filter that can be used as value for a <c>QueryBuildRange</c>
        #///    object.
        #/// </returns>
        #/// <remarks>
        #///    This method generally returns the string in the format of '_from..._to'. If the <paramref
        #///    name="_from" /> parameter is null or if the <paramref name="_from" /> parameter is an empty value
        #///    and the <paramref name="treatOnlyNullAsUnbound" /> parameter is set to false, and the value is
        #///    dropped from the string and becomes '...<paramref name="_to" />'. The <paramref name="_from" />
        #///    parameter in this case represents an unbound value. The same is true for the <paramref name="_to"
        #///    /> parameter. When both <paramref name="_from" /> and <paramref name="_to" /> are unbound values,
        #///    the function returns an empty string and the range filter will be dropped from the query when it is
        #///    used as a value for a <c>QueryBuildRange</c> object.For the <paramref name="treatOnlyNullAsUnbound"
        #///    /> parameter, empty values are defined as values that are the equivalent of false. So an empty
        #///    value for an integers is 0, an empty string for strings, the <c>datenull</c> method returning true
        #///    for dates, and so on.
        #/// </remarks>
        #public static str range(anytype _from, anytype _to, boolean treatOnlyNullAsUnbound = false)
        #{
        #    str range;
        #    // <GEERU>
        #    boolean ru      = SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]);
        #    boolean hasFrom;
        #    boolean hasTo;
        #    boolean type;
        #    boolean sysQuery;
        #
        #    type     = typeOf(_from) != Types::String && typeOf(_from) != Types::Date;
        #    sysQuery = treatOnlyNullAsUnbound && !SysQuery::isNullValue(_from);
        #    hasFrom  = _from || (ru ? type : sysQuery);
        #
        #    type     = typeOf(_to) != Types::String && typeOf(_to) != Types::Date;
        #    sysQuery = treatOnlyNullAsUnbound && !SysQuery::isNullValue(_to);
        #    hasTo    = _to || (ru ? type : sysQuery);
        #    // </GEERU>
        #
        #    if (hasFrom)
        #    {
        #        range += queryValue(_from);
        #    }
        #    if (hasFrom || hasTo)
        #    {
        #        range += '..';
        #    }
        #    // <GEERU>
        #    else if (ru)
        #    {
        #        range = SysQuery::valueEmptyString();
        #    }
        #    // </GEERU>
        #    if (hasTo)
        #    {
        #        range += queryValue(_to);
        #    }
        #
        #    return range;
        #}
      ENDSOURCE
      SOURCE #tableOccurrence
        #// AOSRunMode::client
        #static client server int tableOccurrence(Query query, TableId tableId, int dataSourceNo)
        #{
        #    DictTable               dictTable;
        #    QueryBuildDataSource    dataSource;
        #    int                     i;
        #    int                     tableOccurrence;
        #    ;
        #
        #    for (i = 1; i <= dataSourceNo; i++)
        #    {
        #        dataSource      = query.dataSourceNo(i);
        #        dictTable       = new DictTable(dataSource.table());
        #
        #        if (tableId == dictTable.id())
        #        {
        #            tableOccurrence++;
        #        }
        #    }
        #
        #    return tableOccurrence;
        #}
      ENDSOURCE
      SOURCE #tableOccurrenceText
        #// AOSRunMode::client
        #static client server str tableOccurrenceText(int tableOccurrence)
        #{
        #    if (tableOccurrence > 1)
        #        return strFmt('(%1)', tableOccurrence);
        #
        #    return '';
        #}
      ENDSOURCE
      SOURCE #unpackCompanyRanges
        #/// <summary>
        #/// Unpacks the ranges that are contained by the <paramref name="companyRanges" /> parameter and adds
        #/// them to the specified query.
        #/// </summary>
        #/// <param name="query">
        #/// A query to which to add the company ranges.
        #/// </param>
        #/// <param name="companyRanges">
        #/// A container that contains the company ranges.
        #/// </param>
        #/// <remarks>
        #/// The container passed in must be in the same format as the container that is retrieved from the
        #/// query on a call of the <c>GetCompanyRanges</c> method.
        #/// </remarks>
        #private static client server void unpackCompanyRanges(Query query, container companyRanges)
        #{
        #    container companyRange;
        #    int numRanges;
        #    int i;
        #    boolean allSelected = true;
        #    ;
        #
        #    if(query.allowCrossCompany())
        #    {
        #        query.clearCompanyRange();
        #
        #        numRanges = conLen(companyRanges);
        #        for(i = 1; i <= numRanges; i++)
        #        {
        #            companyRange = conPeek(companyRanges, i);
        #            if(conPeek(companyRange, #isSelected))
        #            {
        #                query.addCompanyRange(conPeek(companyRange, #companyId));
        #            }
        #            else
        #            {
        #                allSelected = false;
        #            }
        #        }
        #
        #        if(allSelected)
        #        {
        #            //If all of the companies are selected that is the equivalent of having a cleared list
        #            query.clearCompanyRange();
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #unpackDataSource
        #private static client server void unpackDataSource(int                  _packVersion,
        #                                                   Query                _query,
        #                                                   container            _dataSourcePack,
        #                                                   QueryBuildDataSource _queryBuildDataSource,
        #                                                   Map                  _origRangeMap,
        #                                                   Map                  _childDataSourceMap,
        #                                                   boolean              _origDataSource,
        #                                                   boolean              _unpackOnlyOpenRanges,
        #                                                   int                  dataSourceNo,
        #                                                   boolean              isQueryUpdated = true,
        #                                                   Map                  _origDimensionRangeMap = null)
        #{
        #    QueryBuildDataSource    childDataSource;
        #    QueryBuildRange         queryBuildRange;
        #    SysDictField            sysDictField;
        #    SysDictField            arrayField;
        #    DictTable               dictTable;
        #    DictIndex               dictIndex;
        #    TableId                 tableId;
        #    TableId                 tableSelector;
        #    TableId                 relatedTableId;
        #    FieldId                 fieldId;
        #    FieldId                 relatedFieldId;
        #    Range                   range;
        #    RangeStatus             rangeStatus;
        #    LabelType               rangeLabel;
        #    SortOrder               sortOrder;
        #    boolean                 autoHeader;
        #    boolean                 autoSum;
        #    boolean                 linkAuto;
        #    container               linkPack;
        #    container               rangePack;
        #    container               origRangePack;
        #    container               indexPack;
        #    container               sortingPack;
        #    container               relatedTablesPack;
        #    container               pack;
        #    container               childDataSourcePack;
        #    MapIterator             mapIterator;
        #    Set                     rangeNoAddSet;
        #    int                     elements;
        #    int                     position;
        #    int                     autoHeaderDetailLevel;
        #    int                     autoSumDetailLevel;
        #    int                     i, j;
        #    boolean                 rangeBelongsToComposite;
        #    str                     fieldName;
        #    str                     tableName;
        #    IndexId                 indexid1;
        #    QueryFetchMode          dataSourceFetchMode;
        #    JoinMode                dataSourceJoinMode;
        #    boolean                 matchingChildDataSouceUniqueId = false;
        #    boolean                 unpackNames;
        #    Map                     collectedSelectionFields = null;
        #    FieldName               parentFieldName, detailFieldName;
        #    DictTable               parentTable, detailTable;
        #    DictField               parentField, detailField;
        #    FieldName               dimensionFieldName;
        #    DimensionComponent      dimensionComponent;
        #    anytype                 DimensionValue;
        #    Name                    dimensionAttributeName;
        #    boolean                 isDefaultRange;
        #
        #    if (_packVersion >=#packPolymorphicDataSourceVersionNoIDsVersion)
        #    {
        #        unpackNames=true;
        #    }
        #    #SysTableNameIdConvVersion(conpeek(conpeek(_dataSourcePack, #packTableIdPos),1),tableId,unpackNames)
        #
        #    if (isQueryUpdated && dataSourceNo == 1)
        #    {
        #        if(!_query.isCompositeQuery())
        #        {
        #            _query.clearGroupBy();
        #            _query.clearHavingFilters();
        #        }
        #        _query.clearOrderBy();
        #        if(!_query.isCompositeQuery())
        #        {
        #            collectedSelectionFields = SysQuery::clearAndCollectSelectionFields(_query);
        #        }
        #    }
        #
        #    if (tableId == _queryBuildDataSource.table())
        #    {
        #        // only set the query data source name from the pack if they are
        #        // of a same table to prevent incorrectly setting the name in case
        #        // of query data source mis-alighment.
        #        if (_packVersion >=#packExtendedDataSourceForDimensionVersion)
        #        {
        #            _queryBuildDataSource.name(conPeek(_dataSourcePack, #packDataSourceNamePos));
        #        }
        #
        #        // unpack link
        #        [linkAuto, linkPack] = conPeek(_dataSourcePack, #packLinkPos);
        #
        #        if (!_origDataSource)
        #        {
        #            if (linkAuto)
        #            {
        #                _queryBuildDataSource.relations(true);
        #            }
        #            else
        #            {
        #                elements = conLen(linkPack);
        #                for (i=1; i<=elements; i++)
        #                {
        #                    parentTable = new DictTable(_queryBuildDataSource.parentDataSource().table());
        #                    detailTable = new DictTable(tableId);
        #
        #                    // Get fieldName from the container
        #                    parentFieldName = conPeek(conPeek(linkPack, i),1);
        #                    detailFieldName = conPeek(conPeek(linkPack, i),2);
        #
        #                    // We need to support SCsc
        #                    parentField = SysDictField::findFieldByName(parentTable.name(), parentFieldName);
        #                    detailField = SysDictField::findFieldByName(detailTable.name(), detailFieldName);
        #                    if (parentField && detailField)
        #                    {
        #                        fieldId = Global::fieldExt2Id(parentField.id());
        #                        relatedFieldId = Global::fieldExt2Id(detailField.id());
        #                        _queryBuildDataSource.addLink(fieldId, relatedFieldId);
        #
        #                    }
        #                }
        #            }
        #        }
        #        // unpack ranges
        #        _queryBuildDataSource.clearRanges();
        #
        #        rangeNoAddSet = new Set(Types::Integer);
        #        if (_origRangeMap &&
        #            _origRangeMap.exists(_queryBuildDataSource.uniqueId()))
        #        {
        #            origRangePack = _origRangeMap.lookup(_queryBuildDataSource.uniqueId());
        #            elements      = conLen(origRangePack);
        #            for (i=1; i<=elements; i++)
        #            {
        #                if (_packVersion >= #packExtendedDataSourceForDimensionVersion)
        #                {
        #                    if(unpackNames)
        #                    {
        #                        [fieldName, rangeLabel, range, rangeStatus, rangeBelongsToComposite,tableName] = conPeek(origRangePack, i);
        #                        tableSelector=tableName2id(tableName);
        #                        fieldId=fieldName2id(tableSelector,fieldName);
        #                    }
        #                    else
        #                    {
        #                        [fieldId, rangeLabel, range, rangeStatus, rangeBelongsToComposite, tableSelector] = conPeek(origRangePack, i);
        #                    }
        #                }
        #                else
        #                {
        #                    [fieldId, rangeLabel, range, rangeStatus, rangeBelongsToComposite] = conPeek(origRangePack, i);
        #                    tableSelector = tableId;
        #                }
        #
        #                if (!fieldId)
        #                {
        #                    fieldId = fieldNum(Common, TableId);
        #                }
        #
        #                queryBuildRange = _queryBuildDataSource.addRange(fieldId);
        #                queryBuildRange.tableSelector(tableSelector);
        #                queryBuildRange.value(range);
        #                queryBuildRange.status(rangeStatus);
        #                queryBuildRange.label(rangeLabel);
        #                if (rangeBelongsToComposite)
        #                {
        #                    queryBuildRange.associateRangeNodeToCompositeQuery();
        #                }
        #
        #
        #                sysDictField = new SysDictField(tableSelector, fieldId);
        #                if (sysDictField.arrayIndex())
        #                {
        #                    if (sysDictField.arrayIndex() == 1)
        #                    {
        #                        rangeNoAddSet.add(fieldExt2Id(sysDictField.id()));
        #                    }
        #                    rangeNoAddSet.add(sysDictField.id());
        #                }
        #                else
        #                {
        #                    rangeNoAddSet.add(sysDictField.id());
        #                    for (j=1; j <= sysDictField.arraySize(); j++)
        #                    {
        #                        arrayField = new SysDictField(tableId, sysDictField.id(), j);
        #                        rangeNoAddSet.add(arrayField.id());
        #                    }
        #
        #                }
        #                if (_packVersion >= #packEnumByValues && sysDictField.baseType() == Types::Enum)
        #                {
        #                    range = DictEnum::queryRangeValues2Names(queryBuildRange);
        #                    queryBuildRange.value(range);
        #                }
        #            }
        #        }
        #
        #        // Unpack dimension ranges
        #        if (_origDimensionRangeMap && _origDimensionRangeMap.exists(_queryBuildDataSource.uniqueId()))
        #        {
        #            origRangePack = _origDimensionRangeMap.lookup(_queryBuildDataSource.uniqueId());
        #            elements      = conLen(origRangePack);
        #            for (i = 1; i <= elements; i++)
        #            {
        #                [dimensionFieldName, dimensionComponent, DimensionValue, dimensionAttributeName, isDefaultRange] =
        #                    conPeek(origRangePack, i);
        #
        #                SysQuery::addDimensionAttributeRange(
        #                    _query,
        #                    _queryBuildDataSource.name(),
        #                    dimensionFieldName,
        #                    dimensionComponent,
        #                    DimensionValue,
        #                    dimensionAttributeName,
        #                    isDefaultRange);
        #            }
        #        }
        #
        #        rangePack   = conPeek(_dataSourcePack, #packRangePos);
        #        elements    = conLen(rangePack);
        #        for (i=1; i<=elements; i++)
        #        {
        #            if (_packVersion >= #packExtendedDataSourceForDimensionVersion)
        #            {
        #                if(unpackNames)
        #                {
        #                    [fieldName, rangeLabel, range, rangeStatus, rangeBelongsToComposite,tableName] = conPeek(rangePack, i);
        #                    tableSelector=tableName2id(tableName);
        #                    fieldId=fieldName2id(tableSelector,fieldName);
        #                }
        #                else
        #                {
        #                    [fieldId, rangeLabel, range, rangeStatus, rangeBelongsToComposite, tableSelector] = conPeek(rangePack, i);
        #                }
        #            }
        #            else
        #            {
        #                [fieldId, rangeLabel, range, rangeStatus, rangeBelongsToComposite] = conPeek(rangePack, i);
        #                tableSelector = tableId;
        #            }
        #            sysDictField     = new SysDictField(tableSelector, fieldId);
        #
        #            if (sysDictField &&
        #                sysDictField.saveContents() &&
        #                (rangeStatus != RangeStatus::Locked || !_origDataSource || !_unpackOnlyOpenRanges))
        #            {
        #                queryBuildRange = _queryBuildDataSource.addRange(fieldId);
        #                queryBuildRange.tableSelector(tableSelector);
        #                queryBuildRange.label(rangeLabel);
        #                queryBuildRange.value(range);
        #                queryBuildRange.status(rangeStatus);
        #                if (rangeBelongsToComposite)
        #                {
        #                    queryBuildRange.associateRangeNodeToCompositeQuery();
        #                }
        #
        #                if (_packVersion >= #packEnumByValues && sysDictField.baseType() == Types::Enum)
        #                {
        #                    range = DictEnum::queryRangeValues2Names(queryBuildRange);
        #                    queryBuildRange.value(range);
        #                }
        #            }
        #        }
        #
        #        // unpack sorting
        #        _queryBuildDataSource.clearSortIndex();
        #
        #        [indexPack, sortingPack] = conPeek(_dataSourcePack, #packSortingPos);
        #        elements                 = conLen(indexPack);
        #        for (i=1; i<=elements; i++)
        #        {
        #            #SysIndexNameIdConvVersion(conpeek(indexPack, i),indexId1,tableId,unpackNames)
        #            dictIndex   = new DictIndex(tableId,indexid1);
        #
        #
        #            if(dictIndex)
        #            {
        #                _queryBuildDataSource.addSortIndex(dictIndex.id());
        #            }
        #        }
        #
        #        position = 0;
        #        elements = conLen(sortingPack);
        #        for (i=1; i<=elements; i++)
        #        {
        #            if (unpackNames)
        #            {
        #                [fieldName, sortOrder, autoHeader, autoSum, autoHeaderDetailLevel, autoSumDetailLevel] = conPeek(sortingPack, i);
        #                fieldId=fieldName2id(tableId,fieldName);
        #            }
        #            else
        #            {
        #                [fieldId, sortOrder, autoHeader, autoSum, autoHeaderDetailLevel, autoSumDetailLevel] = conPeek(sortingPack, i);
        #            }
        #
        #            sysDictField = new SysDictField(tableId, fieldId);
        #
        #            if (sysDictField &&
        #                sysDictField.saveContents())
        #            {
        #                position++;
        #                _queryBuildDataSource.addSortField(fieldId);
        #                _queryBuildDataSource.sortDirection(position, sortOrder);
        #                _queryBuildDataSource.autoHeader(position, autoHeader);
        #                _queryBuildDataSource.autoHeaderDetailLevel(position, autoHeaderDetailLevel);
        #                _queryBuildDataSource.autoSum(position, autoSum);
        #                _queryBuildDataSource.autoSumDetailLevel(position, autoSumDetailLevel);
        #            }
        #        }
        #
        #        // Unpack tables
        #        if (_queryBuildDataSource.allowAdd() == QueryAllowAdd::AllFields)
        #        {
        #            relatedTablesPack   = conPeek(_dataSourcePack, #packRelatedTablesPos);
        #            elements            = conLen(relatedTablesPack);
        #
        #            if (_childDataSourceMap)
        #            {
        #                if (_childDataSourceMap.exists(_queryBuildDataSource.uniqueId()))
        #                {
        #                    mapIterator = new MapIterator(_childDataSourceMap.lookup(_queryBuildDataSource.uniqueId()));
        #                }
        #            }
        #
        #            for (i=1; i<=elements; i++)
        #            {
        #                pack             = conPeek(relatedTablesPack, i);
        #                childDataSource  = null;
        #
        #                if (mapIterator)
        #                {
        #                    mapIterator.begin();
        #                    while (mapIterator.more())
        #                    {
        #                        childDataSourcePack = mapIterator.value();
        #                        if (_packVersion >= #packExtendedDataSourceForDimensionVersion)
        #                        {
        #                            matchingChildDataSouceUniqueId = (conPeek(childDataSourcePack,#packDataSourceUniqueIdPos) == conPeek(pack,#packDataSourceUniqueIdPos));
        #                        }
        #                        else
        #                        {
        #                            matchingChildDataSouceUniqueId = true;
        #                        }
        #                        if (conPeek(childDataSourcePack, #packTableIdPos) == conPeek(pack, #packTableIdPos) &&
        #                            conPeek(childDataSourcePack, #packLinkPos)    == conPeek(pack, #packLinkPos) &&
        #                            matchingChildDataSouceUniqueId)
        #                        {
        #                            childDataSource = _query.dataSourceUniqueId(mapIterator.key());
        #                            childDataSource.enabled(true);
        #                            break;
        #                        }
        #                        mapIterator.next();
        #                    }
        #                }
        #
        #                if (childDataSource)
        #                {
        #                    SysQuery::unpackDataSource(_packVersion, _query, pack, childDataSource, _origRangeMap, _childDataSourceMap, true, _unpackOnlyOpenRanges, dataSourceNo + i, true, _origDimensionRangeMap);
        #                }
        #                else
        #                {
        #                    #SysTableNameIdConvVersion(conpeek(conpeek(pack, #packTableIdPos),1),relatedTableId,unpackNames)
        #                    dictTable        = new DictTable(relatedTableId);
        #
        #                    if (dictTable)
        #                    {
        #                        if (_packVersion >= #packExtendedDataSourceForDimensionVersion)
        #                        {
        #                            dataSourceJoinMode = conPeek(pack, #packDataSourceJoinModePos);
        #                            dataSourceFetchMode = conPeek(pack, #packDataSourceFetchModePos);
        #                        }
        #                        else
        #                        {
        #                            dataSourceJoinMode = JoinMode::ExistsJoin;
        #                            dataSourceFetchMode = QueryFetchMode::One2One;
        #                        }
        #
        #                        childDataSource = _queryBuildDataSource.addDataSource(relatedTableId);
        #                        childDataSource.joinMode(dataSourceJoinMode);
        #                        childDataSource.fetchMode(dataSourceFetchMode);
        #                        SysQuery::unpackDataSource(_packVersion,_query, pack, childDataSource, _origRangeMap, _childDataSourceMap, false, _unpackOnlyOpenRanges, dataSourceNo + i, true, _origDimensionRangeMap);
        #                    }
        #                }
        #            }
        #        }
        #
        #        if (isQueryUpdated && dataSourceNo == 1)
        #        {
        #            SysQuery::unpackGroupAndOrder(_query, _dataSourcePack, _packVersion);
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #unpackDataSourceAggregates
        #/// <summary>
        #/// Unpacks the previously packed aggregate information into the data source.
        #/// </summary>
        #/// <param name="_query">
        #/// A query with aggregate fields.
        #/// </param>
        #/// <param name="pack">
        #/// A container that contains the packed aggregate information.
        #/// </param>
        #private static void unpackDataSourceAggregates(Query _query, container pack)
        #{
        #    int             packLen, dataSourceUniqueId, i;
        #    FieldId         fldId;
        #    SelectionField  selType;
        #    QueryBuildDataSource dataSource;
        #
        #    packLen = conLen(pack);
        #    for (i=1; i<=packLen; i++)
        #    {
        #        [fldId, selType, dataSourceUniqueId] = conPeek(pack, i);
        #        if(! _query.isCompositeQuery())
        #        {
        #            dataSource = _query.dataSourceUniqueId(dataSourceUniqueId);
        #            dataSource.addSelectionField(fldId, selType);
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #unpackDataSourceHaving
        #/// <summary>
        #/// This method unpacks previously packed having clause information into the data source.
        #/// </summary>
        #/// <param name="_query">
        #/// A query with having clause fields.
        #/// </param>
        #/// <param name="pack">
        #/// A container with packed having clause information
        #/// </param>
        #private static void unpackDataSourceHaving(Query _query, container pack)
        #{
        #    Counter                 packLength, filterCounter;
        #    QueryBuildDataSource    dataSource;
        #    int                     dataSourceUniqueId;
        #    FieldName               fieldName;
        #    AggregateFunction       aggregateFunction;
        #    str                     rangeValue;
        #    QueryHavingFilter       queryHavingFilter;
        #
        #    packLength = conLen(pack);
        #    for (filterCounter=1; filterCounter<=packLength; filterCounter++)
        #    {
        #        [dataSourceUniqueId, fieldName, aggregateFunction, rangeValue] = conPeek(pack, filterCounter);
        #        if(! _query.isCompositeQuery())
        #        {
        #            dataSource = _query.dataSourceUniqueId(dataSourceUniqueId);
        #            queryHavingFilter = _query.addHavingFilter(dataSource, fieldName, aggregateFunction);
        #            queryHavingFilter.value(rangeValue);
        #        }
        #    }
        #}
      ENDSOURCE
      SOURCE #unpackDimensionRanges
        #/// <summary>
        #/// Unpacks dimension ranges for a query.
        #/// </summary>
        #/// <param name="_query">
        #/// The Query to add ranges to.
        #/// </param>
        #/// <param name="_packedDimensionRanges">
        #/// The container containing the packed dimension ranges.
        #/// </param>
        #/// <param name="packVersion">
        #/// The pack version of the query.
        #/// </param>
        #private static client server void unpackDimensionRanges(Query _query, container _packedDimensionRanges, int packVersion)
        #{
        #    int                     numRanges;
        #    int                     i;
        #
        #    str                     dataSourceName;
        #    str                     dimensionFieldName;
        #    str                     dimensionAttributeName;
        #    boolean                 rangeEnabled;
        #    int                     rangeStatus;
        #    str                     rangeValue;
        #    DimensionComponent      dimensionComponent;
        #    boolean                 isDefaultRange;
        #
        #    SysQuery::clearDimensionRangesFromQuery(_query);
        #
        #    // Unpack ranges
        #    numRanges = conLen(_packedDimensionRanges);
        #    for (i = 1; i <= numRanges; i++)
        #    {
        #        [#dimensionDataSourceRangeCurrentList] = conPeek(_packedDimensionRanges, i);
        #
        #        SysQuery::addDimensionAttributeRange(_query, dataSourceName, dimensionFieldName, dimensionComponent, rangeValue, dimensionAttributeName, isDefaultRange);
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #unpackGroupAndOrder
        #private static client server void unpackGroupAndOrder(Query                _query,
        #                                                      container            _dataSourcePack,
        #                                                      int                  _packVersion)
        #{
        #    int                     i;
        #    int                     uniqueID;
        #    int                     elements;
        #    int                     autoHeaderDetailLevel;
        #    str                     fieldName;
        #    str                     tableName;
        #    int                     autoSumDetailLevel;
        #    FieldId                 fieldId;
        #    TableId                 tableId;
        #    TableId                 tableSelector;
        #    SortOrder               sortOrder;
        #    boolean                 autoSum;
        #    boolean                 autoHeader;
        #    boolean                 unpackNames;
        #    container               havingPack;
        #    container               groupByPack;
        #    container               orderByPack;
        #    container               aggregatePack;
        #    SysDictField            sysDictField;
        #    QueryGroupByField       groupByField;
        #    QueryOrderByField       orderbyField;
        #    QueryBuildDataSource    tempDataSource;
        #    Map                     collectedSelectionFields = null;
        #    boolean                 isDimension;
        #    DimensionComponent      dimensionComponent;
        #    Name                    dimensionAttributeName;
        #
        #    if (_packVersion >=#packPolymorphicDataSourceVersionNoIDsVersion)
        #    {
        #        unpackNames=true;
        #    }
        #
        #    if(!_query.isCompositeQuery())
        #    {
        #        _query.clearGroupBy();
        #        _query.clearHavingFilters();
        #    }
        #    _query.clearOrderBy();
        #    if(!_query.isCompositeQuery())
        #    {
        #        collectedSelectionFields = SysQuery::clearAndCollectSelectionFields(_query);
        #    }
        #
        #    if (conLen(_dataSourcePack) >= #packGroupByPos)
        #    {
        #        groupByPack = conPeek(_dataSourcePack, #packGroupByPos);
        #        elements = conLen(groupByPack);
        #        for (i=1; i<=elements; i++)
        #        {
        #            if (_packVersion >= #packPolymorphicDataSourceVersion)
        #            {
        #                if (unpackNames)
        #                {
        #                    [uniqueID, fieldName, autoHeader, autoHeaderDetailLevel, autoSum, autoSumDetailLevel, tableName] = conPeek(groupByPack, i);
        #                    tableSelector=tableName2id(tableName);
        #                    fieldId=fieldName2id(tableSelector,fieldName);
        #                }
        #                else
        #                {
        #                    [uniqueID, fieldId, autoHeader, autoHeaderDetailLevel, autoSum, autoSumDetailLevel, tableSelector] = conPeek(groupByPack, i);
        #                }
        #            }
        #            else
        #            {
        #                [uniqueID, fieldId, autoHeader, autoHeaderDetailLevel, autoSum, autoSumDetailLevel] = conPeek(groupByPack, i);
        #                tableSelector = tableId;
        #            }
        #
        #            tempDataSource = _query.dataSourceUniqueId(uniqueID);
        #            if (tempDataSource)
        #            {
        #                sysDictField = new SysDictField(tableSelector, fieldId);
        #
        #                if (sysDictField && ! _query.isCompositeQuery())
        #                {
        #                    groupByField = tempDataSource.addGroupByField(fieldId);
        #                    groupByField.tableSelector(tableSelector);
        #                    groupByField.autoHeader(autoHeader);
        #                    groupByField.autoHeaderDetailLevel(autoHeaderDetailLevel);
        #                    groupByField.autoSum(autoSum);
        #                    groupByField.autoSumDetailLevel(autoSumDetailLevel);
        #                }
        #            }
        #        }
        #    }
        #
        #    // Unpack Order By Fields
        #    if (conLen(_dataSourcePack) >= #packOrderByPos)
        #    {
        #        orderByPack = conPeek(_dataSourcePack, #packOrderByPos);
        #        elements = conLen(orderByPack);
        #        for (i=1; i<=elements; i++)
        #        {
        #            if (_packVersion >= #packDimensionRangesVersion)
        #            {
        #                if(unpackNames)
        #                {
        #                    [uniqueID, fieldName, sortOrder, autoHeader, autoHeaderDetailLevel, autoSum, autoSumDetailLevel, tableName, isDimension, dimensionComponent, dimensionAttributeName] = conPeek(orderByPack, i);
        #                    tableSelector=tableName2id(tableName);
        #                    fieldId=fieldName2id(tableSelector,fieldName);
        #                }
        #                else
        #                {
        #                    [uniqueID, fieldId, sortOrder, autoHeader, autoHeaderDetailLevel, autoSum, autoSumDetailLevel, tableSelector, isDimension, dimensionComponent, dimensionAttributeName] = conPeek(orderByPack, i);
        #                }
        #            }
        #            else if (_packVersion >= #packExtendedDataSourceForDimensionVersion)
        #            {
        #                if(unpackNames)
        #                {
        #                    [uniqueID, fieldName, sortOrder, autoHeader, autoHeaderDetailLevel, autoSum, autoSumDetailLevel,tableName] = conPeek(orderByPack, i);
        #                    tableSelector=tableName2id(tableName);
        #                    fieldId=fieldName2id(tableSelector,fieldName);
        #                }
        #                else
        #                {
        #                    [uniqueID, fieldId, sortOrder, autoHeader, autoHeaderDetailLevel, autoSum, autoSumDetailLevel,tableSelector] = conPeek(orderByPack, i);
        #                }
        #            }
        #            else
        #            {
        #                [uniqueID, fieldId, sortOrder, autoHeader, autoHeaderDetailLevel, autoSum, autoSumDetailLevel] = conPeek(orderByPack, i);
        #                tableSelector = tableId;
        #            }
        #
        #
        #            tempDataSource = _query.dataSourceUniqueId(uniqueID);
        #            if (tempDataSource)
        #            {
        #                sysDictField = new SysDictField(tableSelector, fieldId);
        #
        #                if (sysDictField &&
        #                    sysDictField.saveContents())
        #                {
        #                    if (isDimension)
        #                    {
        #                        SysQuery::addOrderByDimensionAttribute(
        #                            _query,
        #                            tempDataSource.name(),
        #                            sysDictField.name(),
        #                            dimensionComponent,
        #                            sortOrder,
        #                            dimensionAttributeName);
        #                    }
        #                    else
        #                    {
        #                        orderbyField = tempDataSource.addOrderByField(fieldId, sortOrder);
        #                        orderbyField.tableSelector(tableSelector);
        #                        orderbyField.autoHeader(autoHeader);
        #                        orderbyField.autoHeaderDetailLevel(autoHeaderDetailLevel);
        #                        orderbyField.autoSum(autoSum);
        #                        orderbyField.autoSumDetailLevel(autoSumDetailLevel);
        #                    }
        #                }
        #            }
        #        }
        #    }
        #
        #    //unpack aggregates and having
        #    if (_packVersion >= #packExtendedDataSourceForDimensionVersion)
        #    {
        #        aggregatePack = conPeek(_dataSourcePack, #packAggregatePos);
        #        SysQuery::unpackDataSourceAggregates(_query, aggregatePack);
        #
        #        havingPack = conPeek(_dataSourcePack, #packHavingPos);
        #        SysQuery::unpackDataSourceHaving(_query, havingPack);
        #    }
        #
        #    //add collected selection fields to the field selection list after
        #    //aggregates have been unpacked.
        #    if ( !_query.isCompositeQuery() )
        #    {
        #        SysQuery::addCollectedSelectionFields(_query,collectedSelectionFields);
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #unpackQueryFilters
        #/// <summary>
        #/// unpack query filters
        #/// </summary>
        #/// <param name="_query">
        #/// The Query to add queryfilters to.
        #/// </param>
        #/// <param name="queryFilters">
        #/// The container containing the query filters.
        #/// </param>
        #/// <param name="packVersion">
        #/// The pack version of the query filters.
        #/// </param>
        #private static client server void unpackQueryFilters(Query _query, container queryFilters, int packVersion)
        #{
        #    FieldName fieldName;
        #    LabelType filterLabel;
        #    RangeStatus filterStatus;
        #    str filterValue;
        #    boolean filterBelongsToComposite;
        #    TableName tableName;
        #    int numFilters;
        #    int i;
        #    TableId tableSelector;
        #    FieldId fieldId;
        #    QueryFilter queryFilter;
        #    QueryBuildDataSource queryBuildDataSource;
        #    int dataSourceUniqueId;
        #    SysDictField sysDictField;
        #
        #    _query.clearQueryFilters();
        #    numFilters = conLen(queryFilters);
        #    for(i=1; i <= numFilters; i++)
        #    {
        #        [fieldName, filterLabel, filterValue, filterStatus, filterBelongsToComposite,tableName,dataSourceUniqueId] = conPeek(queryFilters, i);
        #        tableSelector=tableName2id(tableName);
        #        fieldId=fieldName2id(tableSelector,fieldName);
        #
        #        queryBuildDataSource = _query.dataSourceUniqueId(dataSourceUniqueId);
        #        if(queryBuildDataSource)
        #        {
        #            queryFilter = _query.addQueryFilter(queryBuildDataSource, fieldName);
        #            queryFilter.value(filterValue);
        #            queryFilter.status(filterStatus);
        #        }
        #
        #        if (packVersion >= #packEnumByValues)
        #        {
        #            sysDictField = new SysDictField(tableSelector, fieldId);
        #            if (sysDictField
        #                && sysDictField.baseType() == Types::Enum)
        #            {
        #                filterValue = DictEnum::queryFilterValues2Names(queryFilter);
        #                queryFilter.value(filterValue);
        #            }
        #        }
        #        // BUG 86133 for tableSelector and label
        #        /*
        #        if(filterBelongsToComposite)
        #        {
        #            // BUG 86133
        #            // ASSOCIATE FILTER TO COMPOSITE QUERY
        #
        #        }
        #        */
        #    }
        #
        #}
      ENDSOURCE
      SOURCE #unpackRangeAndSortorder
        #public static client server boolean unpackRangeAndSortorder(Query _query, container _pack, int _queryNextUniqueId = 0, boolean _unpackOnlyOpenRanges = true)
        #{
        #    boolean                 ok;
        #    QueryBuildDataSource    queryBuildDataSource;
        #    QueryBuildDataSource    parentDataSource;
        #    QueryBuildRange         queryBuildRange;
        #    container               queryPack;
        #    container               pack;
        #    container               rangeFieldPack;
        #    container               tmp;
        #    int                     elements;
        #    int                     dataSourcePackElements;
        #    int                     rangeCnt;
        #    int                     i, j,k;
        #    int                     packVersion;
        #    int                     queryNextUniqueId   = _queryNextUniqueId;
        #    Map                     rangePackMap        = new Map(Types::Integer, Types::Container);
        #    Map                     dimensionPackMap    = new Map(Types::Integer, Types::Container);
        #    Map                     childDataSourceMap  = new Map(Types::Integer, Types::Class);
        #    List                    dimensionRangeList;
        #    ListEnumerator          dimensionRangeListEnum;
        #    Map                     map;
        #    str                     dataSourceName;
        #    str                     dimensionFieldName;
        #    str                     dimensionAttributeName;
        #    boolean                 rangeEnabled;
        #    int                     rangeStatus;
        #    str                     rangeValue;
        #    DimensionComponent      dimensionComponent;
        #    boolean                 isDefaultRange;
        #    DictField               dictField;
        #    DictField               dictFieldByName;
        #    Types                   rangeType;
        #
        #    if (_query)
        #    {
        #        elements    = _query.dataSourceCount();
        #        pack        = SysQuery::updatePackedRangesAndSorting(_pack, queryNextUniqueId);
        #        dimensionRangeList = SysQuery::getDimensionRangesFromQuery(_query);
        #
        #        if (pack)
        #        {
        #            ok          = true;
        #            packVersion = conPeek(pack, 1);
        #            queryPack   = conPeek(pack, 2);
        #
        #            if (queryPack)
        #            {
        #                if (!queryNextUniqueId)
        #                {
        #                    queryNextUniqueId = _query.getNextUniqueId();
        #                }
        #
        #                if (_unpackOnlyOpenRanges)
        #                {
        #                    for (i = 1; i <= elements; i++)
        #                    {
        #                        queryBuildDataSource    = _query.dataSourceNo(i);
        #                        rangeFieldPack          = conNull();
        #                        k                       = 0;
        #
        #                        // Pack QueryBuildDataSource
        #                        rangeCnt = queryBuildDataSource.rangeCount();
        #                        for (j=1; j<=rangeCnt; j++)
        #                        {
        #                            queryBuildRange = queryBuildDataSource.range(j);
        #
        #                            dictField = new DictField(queryBuildRange.tableSelector()? queryBuildRange.tableSelector(): queryBuildDataSource.table(), queryBuildRange.field());
        #
        #                            if(dictField)
        #                            {
        #                                rangeType = dictField.baseType();
        #                            }
        #                            else
        #                            {
        #                                // If tableSelector is not set above, this could lead to potentially wrong result for dictField (ie: derived field)
        #                                // Therefore, we need to to find fieldName by going down chain
        #                                // In the case of derived fields, we need to pack with the right fieldName and tableName
        #                                dictFieldByName = SysDictField::findFieldByName(tableId2name(queryBuildRange.dataSource().table()), queryBuildRange.fieldName());
        #                                if(dictFieldByName)
        #                                {
        #                                    rangeType = dictFieldByName.baseType();
        #                                }
        #                            }
        #
        #                            rangeValue = queryBuildRange.value();
        #                            if (packVersion >= #packEnumByValues && rangeType == Types::Enum)
        #                            {
        #                                rangeValue = DictEnum::queryRangeNames2Values(queryBuildRange);
        #                            }
        #
        #                            if (queryBuildRange &&
        #                                    (queryBuildRange.status() == RangeStatus::Locked)
        #                                )
        #                            {
        #                                tmp            = [fieldId2name((queryBuildRange.tableSelector()? queryBuildRange.tableSelector(): queryBuildDataSource.table()),queryBuildRange.field()),
        #                                                    queryBuildRange.label(),
        #                                                    rangeValue,
        #                                                    queryBuildRange.status(),
        #                                                    queryBuildRange.doesRangeNodeBelongToCompositeQuery(),
        #                                                    tableId2name(queryBuildRange.tableSelector()? queryBuildRange.tableSelector(): queryBuildDataSource.table())
        #                                                    ];
        #                                k++;
        #                                rangeFieldPack = conIns(rangeFieldPack, k, tmp);
        #                            }
        #                        }
        #                        rangePackMap.insert(queryBuildDataSource.uniqueId(),rangeFieldPack);
        #
        #                        // Pack the dimension ranges
        #                        rangeFieldPack = conNull();
        #                        k = 0;
        #                        dimensionRangeListEnum = dimensionRangeList.getEnumerator();
        #                        while (dimensionRangeListEnum.moveNext())
        #                        {
        #                            [#dimensionDataSourceRangeCurrentList] = dimensionRangeListEnum.current();
        #
        #                            if (dataSourceName == queryBuildDataSource.name())
        #                            {
        #                                tmp = [dimensionFieldName, dimensionComponent, rangeValue, dimensionAttributeName, isDefaultRange];
        #                                k++;
        #                                rangeFieldPack = conIns(rangeFieldPack, k, tmp);
        #                            }
        #                        }
        #                        dimensionPackMap.insert(queryBuildDataSource.uniqueId(), rangeFieldPack);
        #                    }
        #                }
        #
        #                for (i = 1; i <= elements; i++)
        #                {
        #                    queryBuildDataSource    = _query.dataSourceNo(i);
        #                    childDataSourceMap.insert(queryBuildDataSource.uniqueId(), new Map(Types::Integer, Types::Container));
        #
        #                    if (queryBuildDataSource.uniqueId() >= queryNextUniqueId)
        #                    {
        #                        if (queryBuildDataSource.level() == 1)
        #                        {
        #                            queryBuildDataSource.enabled(true);
        #                        }
        #                        else
        #                        {
        #                            parentDataSource = queryBuildDataSource.parentDataSource();
        #                            if (parentDataSource)
        #                            {
        #                                queryBuildDataSource.enabled(true);
        #                                map = childDataSourceMap.lookup(parentDataSource.uniqueId());
        #                                map.insert(queryBuildDataSource.uniqueId(), SysQuery::packDataSource(packVersion,_query, queryBuildDataSource.uniqueId(), queryNextUniqueId, i));
        #                            }
        #                            queryBuildDataSource.enabled(false);
        #                        }
        #                    }
        #                }
        #
        #                dataSourcePackElements = conLen(queryPack);
        #                j                      = 0;
        #
        #                for (i=1; i <= _query.dataSourceCount(); i++)
        #                {
        #                    queryBuildDataSource    = _query.dataSourceNo(i);
        #
        #                    if (dataSourcePackElements > j &&
        #                        queryBuildDataSource.enabled() &&
        #                        (queryBuildDataSource.uniqueId() < queryNextUniqueId ||
        #                         queryBuildDataSource.level() == 1))
        #                    {
        #                        j++;
        #                        SysQuery::unpackDataSource(packVersion,
        #                                                   _query,
        #                                                   conPeek(queryPack, j),
        #                                                   queryBuildDataSource,
        #                                                   rangePackMap ,
        #                                                   childDataSourceMap,
        #                                                   true,
        #                                                   _unpackOnlyOpenRanges,
        #                                                   i,
        #                                                   false,
        #                                                   dimensionPackMap);
        #                    }
        #                }
        #            }
        #
        #            if (packVersion >= #packCompanyRangeAndInternalsVersion)
        #            {
        #                SysQuery::unpackCompanyRanges(_query, conPeek(pack, 3));
        #                _query.unpackInternals(conPeek(pack, 4));
        #
        #                // Date Effective: unpack valid time ranges
        #                if (packVersion>= #packValidTimeRangesVersion)
        #                {
        #                    SysQuery::unpackValidTimeRanges(_query,conPeek(pack,5));
        #                }
        #            }
        #
        #            if (packVersion >= #packQueryFilterVersion)
        #            {
        #                SysQuery::unpackQueryFilters(_query,conPeek(pack,6),packVersion);
        #            }
        #
        #            if (packVersion >= #packDimensionRangesVersion)
        #            {
        #                SysQuery::unpackDimensionRanges(_query, conPeek(pack, 7), packVersion);
        #            }
        #            if (queryPack)
        #            {
        #                SysQuery::unpackGroupAndOrder(_query, conPeek(queryPack, 1), packVersion);
        #
        #            }
        #        }
        #    }
        #
        #    return ok;
        #}
      ENDSOURCE
      SOURCE #unpackValidTimeRanges
        #/// <summary>
        #///    Unpacks the ranges that are contained by the specified valid time ranges container and adds them to
        #///    the specified query.
        #/// </summary>
        #/// <param name="query">
        #///    The instance of the <c>Query</c> class to which to add the company ranges.
        #/// </param>
        #/// <param name="validTimeRanges">
        #///    The container that contains the valid time ranges.
        #/// </param>
        #/// <remarks>
        #///    The specified container must be in the same format as the container that is retrieved from the
        #///    query on the call of the <c>GetvalidTimeRanges</c> method on the specified query.
        #/// </remarks>
        #private static client server void unpackValidTimeRanges(Query query, container validTimeRanges)
        #{
        #    ValidTimeStateQueryType type;
        #    boolean isDatetime;
        #    date asOfDate, endRangeDate;
        #    utcdatetime asOfDateTime, endRangeDatetime;
        #    ;
        #
        #    [type] = conPeek(validTimeRanges, #validTimeStateQueryType);
        #    [isDatetime] = conPeek(validTimeRanges, #validTimeIsDatetime);
        #
        #    switch ( type )
        #    {
        #    case ValidTimeStateQueryType::Current:
        #        query.resetValidTimeStateQueryType();
        #    break;
        #    case ValidTimeStateQueryType::AsOf:
        #        if ( isDatetime )
        #        {
        #            [asOfDateTime] = conPeek(validTimeRanges,#validTimeRanges);
        #            query.validTimeStateAsOfDateTime(asOfDateTime);
        #        }
        #        else
        #        {
        #            [asOfDate] = conPeek(validTimeRanges,#validTimeRanges);
        #            query.validTimeStateAsOfDate(asOfDate);
        #        }
        #    break;
        #    case ValidTimeStateQueryType::Range:
        #        if ( isDatetime )
        #        {
        #            [asOfDateTime, endRangeDatetime] = conPeek(validTimeRanges,#validTimeRanges);
        #            query.validTimeStateDateTimeRange(asOfDateTime,endRangeDatetime);
        #        }
        #        else
        #        {
        #            [asOfDate, endRangeDate] = conPeek(validTimeRanges,#validTimeRanges);
        #            query.validTimeStateDateRange(asOfDate,endRangeDate);
        #        }
        #    break;
        #    }
        #}
      ENDSOURCE
      SOURCE #updatePackedRangesAndSorting
        #public static client server container updatePackedRangesAndSorting(container _pack, int _queryNextUniqueId = 0)
        #{
        #    container               pack;
        #    int                     version;
        #    ;
        #
        #    if (typeOf(conPeek(_pack, 1)) == Types::Integer)
        #    {
        #        version     = conPeek(_pack, 1);
        #    }
        #
        #    if (version >= #packRangeAndSortVersion)
        #    {
        #        pack = _pack;
        #    }
        #    else
        #    {
        #        if (queryIsPackedOk(_pack))
        #        {
        #            pack = SysQuery::packRangeAndSortorder(new Query(_pack), _queryNextUniqueId);
        #        }
        #    }
        #
        #    return pack;
        #}
      ENDSOURCE
      SOURCE #value
        #public static str value(anytype a)
        #{
        #    str quotableStr = ' *",.()\\';
        #    str s;
        #    int t;
        #
        #    str doEscape(str s1)
        #    {
        #        int i = 1;
        #        int pos;
        #        int len = strLen(s1);
        #        str result;
        #        str specialChars = ' *",.()<>!=';
        #        boolean escape;
        #
        #        escape = true;
        #        pos = strFind(s1, quotableStr, i, len - i + 1);
        #        while (pos)
        #        {
        #            if (subStr(s1, pos, 1) == '\\')
        #            {
        #                if (strFind(s1, specialChars, pos + 1, 1))
        #                {
        #                   escape = false;
        #                }
        #            }
        #            if (escape)
        #            {
        #                result += subStr(s1, i, pos - i) + '\\' + subStr(s1, pos, 1);
        #            }
        #            else
        #            {
        #                result += subStr(s1, i, pos - i + 1);
        #                escape = true;
        #            }
        #            i = pos + 1;
        #            if (i<=len)
        #                pos = strFind(s1, quotableStr, i, len - i + 1);
        #            else
        #                pos = 0;
        #        }
        #
        #        if (i == 1)
        #            return s1;
        #
        #        if (i<=len)
        #            result += subStr(s1, i, len - i + 1);
        #
        #        return result;
        #    }
        #
        #    t = typeOf(a);
        #    switch (t)
        #    {
        #        case Types::Enum:
        #            return enum2Value(a);
        #        case Types::Real:
        #            return num2str(a,0,16,1,0);
        #        case Types::Date:
        #        case Types::UtcDateTime:
        #            return strFmt('\"%1\"',a);  // must be double quotes
        #        case    Types::String,
        #                Types::RString,
        #                Types::VarString:
        #            s = a;
        #            if (!s)
        #                return SysQuery::valueEmptyString();
        #            return strFmt('%1',doEscape(s));  // must be double quotes
        #
        #    }
        #    // <GEERU>
        #    // to avoid stack trace on unsupported value 'null'
        #    if (! new DictEnum(enumNum(Types)).value2Symbol(t))
        #    {
        #        return SysQuery::valueUnlimited();
        #    }
        #    // </GEERU>
        #    return strFmt('%1',a);
        #}
      ENDSOURCE
      SOURCE #valueEmptyString
        #// Used when you want to have a range which must have a blank value
        #// use this method for future compability
        #public static str valueEmptyString()
        #{
        #    return '\"\"';
        #}
      ENDSOURCE
      SOURCE #valueLike
        #public static str valueLike(anytype a)
        #{
        #    return strFmt('*%1*', a);
        #}
      ENDSOURCE
      SOURCE #valueLikeAfter
        #public static str valueLikeAfter(anytype a)
        #{
        #    return strFmt('%1*', a);
        #}
      ENDSOURCE
      SOURCE #valueNot
        #public static str valueNot(anytype a)
        #{
        #    return strFmt('!%1',SysQuery::value(a));
        #}
      ENDSOURCE
      SOURCE #valueNotEmptyString
        #// Used when you want to have a range which must NOT have a blank value
        #// use this method for future compability
        #public static str valueNotEmptyString()
        #{
        #    return '!\"\"';
        #}
        #
      ENDSOURCE
      SOURCE #valueUnlimited
        #// Used when you want to have a completely open range, no limitations; "a blank range"
        #// use this method for future compability
        #public static str valueUnlimited()
        #{
        #    return '';
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: END
